/* automatically generated by rust-bindgen */
use std;
use std::libc::*;
pub type ptrdiff_t = c_long;
pub type size_t = c_ulong;
pub type wchar_t = c_int;
pub type __u_char = c_uchar;
pub type __u_short = c_ushort;
pub type __u_int = c_uint;
pub type __u_long = c_ulong;
pub type __int8_t = c_schar;
pub type __uint8_t = c_uchar;
pub type __int16_t = c_short;
pub type __uint16_t = c_ushort;
pub type __int32_t = c_int;
pub type __uint32_t = c_uint;
pub type __int64_t = c_long;
pub type __uint64_t = c_ulong;
pub type __quad_t = c_long;
pub type __u_quad_t = c_ulong;
pub type __dev_t = c_ulong;
pub type __uid_t = c_uint;
pub type __gid_t = c_uint;
pub type __ino_t = c_ulong;
pub type __ino64_t = c_ulong;
pub type __mode_t = c_uint;
pub type __nlink_t = c_ulong;
pub type __off_t = c_long;
pub type __off64_t = c_long;
pub type __pid_t = c_int;
pub struct __fsid_t {
    __val: [c_int, ..2u],
}
pub type __clock_t = c_long;
pub type __rlim_t = c_ulong;
pub type __rlim64_t = c_ulong;
pub type __id_t = c_uint;
pub type __time_t = c_long;
pub type __useconds_t = c_uint;
pub type __suseconds_t = c_long;
pub type __daddr_t = c_int;
pub type __key_t = c_int;
pub type __clockid_t = c_int;
pub type __timer_t = *mut c_void;
pub type __blksize_t = c_long;
pub type __blkcnt_t = c_long;
pub type __blkcnt64_t = c_long;
pub type __fsblkcnt_t = c_ulong;
pub type __fsblkcnt64_t = c_ulong;
pub type __fsfilcnt_t = c_ulong;
pub type __fsfilcnt64_t = c_ulong;
pub type __fsword_t = c_long;
pub type __ssize_t = c_long;
pub type __syscall_slong_t = c_long;
pub type __syscall_ulong_t = c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut c_schar;
pub type __intptr_t = c_long;
pub type __socklen_t = c_uint;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub struct Struct_timespec {
    tv_sec: __time_t,
    tv_nsec: __syscall_slong_t,
}
pub struct Struct_tm {
    tm_sec: c_int,
    tm_min: c_int,
    tm_hour: c_int,
    tm_mday: c_int,
    tm_mon: c_int,
    tm_year: c_int,
    tm_wday: c_int,
    tm_yday: c_int,
    tm_isdst: c_int,
    tm_gmtoff: c_long,
    tm_zone: *c_schar,
}
pub struct Struct_itimerspec {
    it_interval: Struct_timespec,
    it_value: Struct_timespec,
}
pub type Struct_sigevent = c_void;
pub type pid_t = __pid_t;
pub struct Struct___locale_struct {
    __locales: [*mut Struct___locale_data, ..13u],
    __ctype_b: *c_ushort,
    __ctype_tolower: *c_int,
    __ctype_toupper: *c_int,
    __names: [*c_schar, ..13u],
}
pub type Struct___locale_data = c_void;
pub type __locale_t = *mut Struct___locale_struct;
pub type locale_t = __locale_t;
pub struct Union_wait {
    data: [c_uchar, ..16u],
}
impl Union_wait {
    pub fn w_status(&mut self) -> *mut c_int {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __wait_terminated(&mut self) -> *mut Struct_Unnamed1 {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __wait_stopped(&mut self) -> *mut Struct_Unnamed2 {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub struct Struct_Unnamed1 {
    __w_termsig: c_uint,
    __w_coredump: c_uint,
    __w_retcode: c_uint,
    unnamed_field1: c_uint,
}
pub struct Struct_Unnamed2 {
    __w_stopval: c_uint,
    __w_stopsig: c_uint,
    unnamed_field1: c_uint,
}
pub struct __WAIT_STATUS {
    data: [c_uchar, ..8u],
}
impl __WAIT_STATUS {
    pub fn __uptr(&mut self) -> *mut *mut Union_wait {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __iptr(&mut self) -> *mut *mut c_int {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub struct div_t {
    quot: c_int,
    rem: c_int,
}
pub struct ldiv_t {
    quot: c_long,
    rem: c_long,
}
pub struct lldiv_t {
    quot: c_longlong,
    rem: c_longlong,
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = c_ulong;
pub type ushort = c_ushort;
pub type _uint = c_uint;
pub type int8_t = c_schar;
pub type int16_t = c_short;
pub type int32_t = c_int;
pub type int64_t = c_long;
pub type u_int8_t = c_uchar;
pub type u_int16_t = c_ushort;
pub type u_int32_t = c_uint;
pub type u_int64_t = c_ulong;
pub type register_t = c_long;
pub type __sig_atomic_t = c_int;
pub struct __sigset_t {
    __val: [c_ulong, ..16u],
}
pub type sigset_t = __sigset_t;
pub struct Struct_timeval {
    tv_sec: __time_t,
    tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = c_long;
pub struct fd_set {
    __fds_bits: [__fd_mask, ..16u],
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = c_ulong;
pub struct Union_pthread_attr_t {
    data: [c_uchar, ..56u],
}
impl Union_pthread_attr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..56u] {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub type pthread_attr_t = Union_pthread_attr_t;
pub struct Struct___pthread_internal_list {
    __prev: *mut Struct___pthread_internal_list,
    __next: *mut Struct___pthread_internal_list,
}
pub type __pthread_list_t = Struct___pthread_internal_list;
pub struct Struct___pthread_mutex_s {
    __lock: c_int,
    __count: c_uint,
    __owner: c_int,
    __nusers: c_uint,
    __kind: c_int,
    __spins: c_int,
    __list: __pthread_list_t,
}
pub struct pthread_mutex_t {
    data: [c_uchar, ..40u],
}
impl pthread_mutex_t {
    pub fn __data(&mut self) -> *mut Struct___pthread_mutex_s {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __size(&mut self) -> *mut [c_schar, ..40u] {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub struct pthread_mutexattr_t {
    data: [c_uchar, ..4u],
}
impl pthread_mutexattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __align(&mut self) -> *mut c_int {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub struct Struct_Unnamed3 {
    __lock: c_int,
    __futex: c_uint,
    __total_seq: c_ulonglong,
    __wakeup_seq: c_ulonglong,
    __woken_seq: c_ulonglong,
    __mutex: *mut c_void,
    __nwaiters: c_uint,
    __broadcast_seq: c_uint,
}
pub struct pthread_cond_t {
    data: [c_uchar, ..48u],
}
impl pthread_cond_t {
    pub fn __data(&mut self) -> *mut Struct_Unnamed3 {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __size(&mut self) -> *mut [c_schar, ..48u] {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __align(&mut self) -> *mut c_longlong {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub struct pthread_condattr_t {
    data: [c_uchar, ..4u],
}
impl pthread_condattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __align(&mut self) -> *mut c_int {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub type pthread_key_t = c_uint;
pub type pthread_once_t = c_int;
pub struct Struct_Unnamed4 {
    __lock: c_int,
    __nr_readers: c_uint,
    __readers_wakeup: c_uint,
    __writer_wakeup: c_uint,
    __nr_readers_queued: c_uint,
    __nr_writers_queued: c_uint,
    __writer: c_int,
    __shared: c_int,
    __pad1: c_ulong,
    __pad2: c_ulong,
    __flags: c_uint,
}
pub struct pthread_rwlock_t {
    data: [c_uchar, ..56u],
}
impl pthread_rwlock_t {
    pub fn __data(&mut self) -> *mut Struct_Unnamed4 {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __size(&mut self) -> *mut [c_schar, ..56u] {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub struct pthread_rwlockattr_t {
    data: [c_uchar, ..8u],
}
impl pthread_rwlockattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..8u] {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub type pthread_spinlock_t = c_int;
pub struct pthread_barrier_t {
    data: [c_uchar, ..32u],
}
impl pthread_barrier_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..32u] {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __align(&mut self) -> *mut c_long {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub struct pthread_barrierattr_t {
    data: [c_uchar, ..4u],
}
impl pthread_barrierattr_t {
    pub fn __size(&mut self) -> *mut [c_schar, ..4u] {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
    pub fn __align(&mut self) -> *mut c_int {
        unsafe { std::cast::transmute(std::ptr::to_mut_unsafe_ptr(self)) }
    }
}
pub struct Struct_random_data {
    fptr: *mut int32_t,
    rptr: *mut int32_t,
    state: *mut int32_t,
    rand_type: c_int,
    rand_deg: c_int,
    rand_sep: c_int,
    end_ptr: *mut int32_t,
}
pub struct Struct_drand48_data {
    __x: [c_ushort, ..3u],
    __old_x: [c_ushort, ..3u],
    __c: c_ushort,
    __init: c_ushort,
    __a: c_ulonglong,
}
pub type __compar_fn_t = extern "C" fn(arg1: *c_void, arg2: *c_void) -> c_int;
pub type uint8_t = c_uchar;
pub type uint16_t = c_ushort;
pub type uint32_t = c_uint;
pub type uint64_t = c_ulong;
pub type int_least8_t = c_schar;
pub type int_least16_t = c_short;
pub type int_least32_t = c_int;
pub type int_least64_t = c_long;
pub type uint_least8_t = c_uchar;
pub type uint_least16_t = c_ushort;
pub type uint_least32_t = c_uint;
pub type uint_least64_t = c_ulong;
pub type int_fast8_t = c_schar;
pub type int_fast16_t = c_long;
pub type int_fast32_t = c_long;
pub type int_fast64_t = c_long;
pub type uint_fast8_t = c_uchar;
pub type uint_fast16_t = c_ulong;
pub type uint_fast32_t = c_ulong;
pub type uint_fast64_t = c_ulong;
pub type intptr_t = c_long;
pub type uintptr_t = c_ulong;
pub type intmax_t = c_long;
pub type uintmax_t = c_ulong;
pub type __gwchar_t = c_int;
pub struct imaxdiv_t {
    quot: c_long,
    rem: c_long,
}
pub type git_cap_t = c_uint;
pub static GIT_CAP_THREADS: c_uint = 1;
pub static GIT_CAP_HTTPS: c_uint = 2;
pub static GIT_CAP_SSH: c_uint = 4;
pub type git_libgit2_opt_t = c_uint;
pub static GIT_OPT_GET_MWINDOW_SIZE: c_uint = 0;
pub static GIT_OPT_SET_MWINDOW_SIZE: c_uint = 1;
pub static GIT_OPT_GET_MWINDOW_MAPPED_LIMIT: c_uint = 2;
pub static GIT_OPT_SET_MWINDOW_MAPPED_LIMIT: c_uint = 3;
pub static GIT_OPT_GET_SEARCH_PATH: c_uint = 4;
pub static GIT_OPT_SET_SEARCH_PATH: c_uint = 5;
pub static GIT_OPT_SET_CACHE_OBJECT_LIMIT: c_uint = 6;
pub static GIT_OPT_SET_CACHE_MAX_SIZE: c_uint = 7;
pub static GIT_OPT_ENABLE_CACHING: c_uint = 8;
pub static GIT_OPT_GET_CACHED_MEMORY: c_uint = 9;
pub type git_error_code = c_int;
pub static GIT_OK: c_int = 0;
pub static GIT_ERROR: c_int = -1;
pub static GIT_ENOTFOUND: c_int = -3;
pub static GIT_EEXISTS: c_int = -4;
pub static GIT_EAMBIGUOUS: c_int = -5;
pub static GIT_EBUFS: c_int = -6;
pub static GIT_EUSER: c_int = -7;
pub static GIT_EBAREREPO: c_int = -8;
pub static GIT_EORPHANEDHEAD: c_int = -9;
pub static GIT_EUNMERGED: c_int = -10;
pub static GIT_ENONFASTFORWARD: c_int = -11;
pub static GIT_EINVALIDSPEC: c_int = -12;
pub static GIT_EMERGECONFLICT: c_int = -13;
pub static GIT_ELOCKED: c_int = -14;
pub static GIT_PASSTHROUGH: c_int = -30;
pub static GIT_ITEROVER: c_int = -31;
pub struct git_error {
    message: *mut c_schar,
    klass: c_int,
}
pub type git_error_t = c_uint;
pub static GITERR_NOMEMORY: c_uint = 0;
pub static GITERR_OS: c_uint = 1;
pub static GITERR_INVALID: c_uint = 2;
pub static GITERR_REFERENCE: c_uint = 3;
pub static GITERR_ZLIB: c_uint = 4;
pub static GITERR_REPOSITORY: c_uint = 5;
pub static GITERR_CONFIG: c_uint = 6;
pub static GITERR_REGEX: c_uint = 7;
pub static GITERR_ODB: c_uint = 8;
pub static GITERR_INDEX: c_uint = 9;
pub static GITERR_OBJECT: c_uint = 10;
pub static GITERR_NET: c_uint = 11;
pub static GITERR_TAG: c_uint = 12;
pub static GITERR_TREE: c_uint = 13;
pub static GITERR_INDEXER: c_uint = 14;
pub static GITERR_SSL: c_uint = 15;
pub static GITERR_SUBMODULE: c_uint = 16;
pub static GITERR_THREAD: c_uint = 17;
pub static GITERR_STASH: c_uint = 18;
pub static GITERR_CHECKOUT: c_uint = 19;
pub static GITERR_FETCHHEAD: c_uint = 20;
pub static GITERR_MERGE: c_uint = 21;
pub type git_off_t = int64_t;
pub type git_time_t = int64_t;
pub type git_otype = c_int;
pub static GIT_OBJ_ANY: c_int = -2;
pub static GIT_OBJ_BAD: c_int = -1;
pub static GIT_OBJ__EXT1: c_int = 0;
pub static GIT_OBJ_COMMIT: c_int = 1;
pub static GIT_OBJ_TREE: c_int = 2;
pub static GIT_OBJ_BLOB: c_int = 3;
pub static GIT_OBJ_TAG: c_int = 4;
pub static GIT_OBJ__EXT2: c_int = 5;
pub static GIT_OBJ_OFS_DELTA: c_int = 6;
pub static GIT_OBJ_REF_DELTA: c_int = 7;
pub type Struct_git_odb = c_void;
pub type git_odb = Struct_git_odb;
pub type Struct_git_odb_backend = c_void;
pub type git_odb_backend = Struct_git_odb_backend;
pub type Struct_git_odb_object = c_void;
pub type git_odb_object = Struct_git_odb_object;
pub type Struct_git_odb_stream = c_void;
pub type git_odb_stream = Struct_git_odb_stream;
pub type Struct_git_odb_writepack = c_void;
pub type git_odb_writepack = Struct_git_odb_writepack;
pub type Struct_git_refdb = c_void;
pub type git_refdb = Struct_git_refdb;
pub type Struct_git_refdb_backend = c_void;
pub type git_refdb_backend = Struct_git_refdb_backend;
pub type Struct_git_repository = c_void;
pub type git_repository = Struct_git_repository;
pub type Struct_git_object = c_void;
pub type git_object = Struct_git_object;
pub type Struct_git_revwalk = c_void;
pub type git_revwalk = Struct_git_revwalk;
pub type Struct_git_tag = c_void;
pub type git_tag = Struct_git_tag;
pub type Struct_git_blob = c_void;
pub type git_blob = Struct_git_blob;
pub type Struct_git_commit = c_void;
pub type git_commit = Struct_git_commit;
pub type Struct_git_tree_entry = c_void;
pub type git_tree_entry = Struct_git_tree_entry;
pub type Struct_git_tree = c_void;
pub type git_tree = Struct_git_tree;
pub type Struct_git_treebuilder = c_void;
pub type git_treebuilder = Struct_git_treebuilder;
pub type Struct_git_index = c_void;
pub type git_index = Struct_git_index;
pub type Struct_git_index_conflict_iterator = c_void;
pub type git_index_conflict_iterator = Struct_git_index_conflict_iterator;
pub type Struct_git_config = c_void;
pub type git_config = Struct_git_config;
pub type Struct_git_config_backend = c_void;
pub type git_config_backend = Struct_git_config_backend;
pub type Struct_git_reflog_entry = c_void;
pub type git_reflog_entry = Struct_git_reflog_entry;
pub type Struct_git_reflog = c_void;
pub type git_reflog = Struct_git_reflog;
pub type Struct_git_note = c_void;
pub type git_note = Struct_git_note;
pub type Struct_git_packbuilder = c_void;
pub type git_packbuilder = Struct_git_packbuilder;
pub struct Struct_git_time {
    time: git_time_t,
    offset: c_int,
}
pub type git_time = Struct_git_time;
pub struct Struct_git_signature {
    name: *mut c_schar,
    email: *mut c_schar,
    when: git_time,
}
pub type git_signature = Struct_git_signature;
pub type Struct_git_reference = c_void;
pub type git_reference = Struct_git_reference;
pub type Struct_git_reference_iterator = c_void;
pub type git_reference_iterator = Struct_git_reference_iterator;
pub type Struct_git_merge_head = c_void;
pub type git_merge_head = Struct_git_merge_head;
pub type Struct_git_status_list = c_void;
pub type git_status_list = Struct_git_status_list;
pub type git_ref_t = c_uint;
pub static GIT_REF_INVALID: c_uint = 0;
pub static GIT_REF_OID: c_uint = 1;
pub static GIT_REF_SYMBOLIC: c_uint = 2;
pub static GIT_REF_LISTALL: c_uint = 3;
pub type git_branch_t = c_uint;
pub static GIT_BRANCH_LOCAL: c_uint = 1;
pub static GIT_BRANCH_REMOTE: c_uint = 2;
pub type git_filemode_t = c_uint;
pub static GIT_FILEMODE_NEW: c_uint = 0;
pub static GIT_FILEMODE_TREE: c_uint = 16384;
pub static GIT_FILEMODE_BLOB: c_uint = 33188;
pub static GIT_FILEMODE_BLOB_EXECUTABLE: c_uint = 33261;
pub static GIT_FILEMODE_LINK: c_uint = 40960;
pub static GIT_FILEMODE_COMMIT: c_uint = 57344;
pub type Struct_git_refspec = c_void;
pub type git_refspec = Struct_git_refspec;
pub type Struct_git_remote = c_void;
pub type git_remote = Struct_git_remote;
pub type Struct_git_push = c_void;
pub type git_push = Struct_git_push;
pub type git_remote_head = Struct_git_remote_head;
pub type git_remote_callbacks = Struct_git_remote_callbacks;
pub struct Struct_git_transfer_progress {
    total_objects: c_uint,
    indexed_objects: c_uint,
    received_objects: c_uint,
    received_bytes: size_t,
}
pub type git_transfer_progress = Struct_git_transfer_progress;
pub type git_transfer_progress_callback =
    extern "C" fn(arg1: *git_transfer_progress, arg2: *mut c_void) -> c_int;
pub type Struct_git_submodule = c_void;
pub type git_submodule = Struct_git_submodule;
pub type git_submodule_update_t = c_int;
pub static GIT_SUBMODULE_UPDATE_RESET: c_int = -1;
pub static GIT_SUBMODULE_UPDATE_CHECKOUT: c_int = 1;
pub static GIT_SUBMODULE_UPDATE_REBASE: c_int = 2;
pub static GIT_SUBMODULE_UPDATE_MERGE: c_int = 3;
pub static GIT_SUBMODULE_UPDATE_NONE: c_int = 4;
pub type git_submodule_ignore_t = c_int;
pub static GIT_SUBMODULE_IGNORE_RESET: c_int = -1;
pub static GIT_SUBMODULE_IGNORE_NONE: c_int = 1;
pub static GIT_SUBMODULE_IGNORE_UNTRACKED: c_int = 2;
pub static GIT_SUBMODULE_IGNORE_DIRTY: c_int = 3;
pub static GIT_SUBMODULE_IGNORE_ALL: c_int = 4;
pub struct Struct_git_oid {
    id: [c_uchar, ..20u],
}
pub type git_oid = Struct_git_oid;
pub type Struct_git_oid_shorten = c_void;
pub type git_oid_shorten = Struct_git_oid_shorten;
pub type git_odb_foreach_cb =
    extern "C" fn(arg1: *git_oid, arg2: *mut c_void) -> c_int;
pub type git_repository_open_flag_t = c_uint;
pub static GIT_REPOSITORY_OPEN_NO_SEARCH: c_uint = 1;
pub static GIT_REPOSITORY_OPEN_CROSS_FS: c_uint = 2;
pub static GIT_REPOSITORY_OPEN_BARE: c_uint = 4;
pub type git_repository_init_flag_t = c_uint;
pub static GIT_REPOSITORY_INIT_BARE: c_uint = 1;
pub static GIT_REPOSITORY_INIT_NO_REINIT: c_uint = 2;
pub static GIT_REPOSITORY_INIT_NO_DOTGIT_DIR: c_uint = 4;
pub static GIT_REPOSITORY_INIT_MKDIR: c_uint = 8;
pub static GIT_REPOSITORY_INIT_MKPATH: c_uint = 16;
pub static GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE: c_uint = 32;
pub type git_repository_init_mode_t = c_uint;
pub static GIT_REPOSITORY_INIT_SHARED_UMASK: c_uint = 0;
pub static GIT_REPOSITORY_INIT_SHARED_GROUP: c_uint = 1533;
pub static GIT_REPOSITORY_INIT_SHARED_ALL: c_uint = 1535;
pub struct git_repository_init_options {
    version: c_uint,
    flags: uint32_t,
    mode: uint32_t,
    workdir_path: *c_schar,
    description: *c_schar,
    template_path: *c_schar,
    initial_head: *c_schar,
    origin_url: *c_schar,
}
pub type git_repository_fetchhead_foreach_cb =
    extern "C" fn
        (arg1: *c_schar, arg2: *c_schar, arg3: *git_oid, arg4: c_uint,
         arg5: *mut c_void) -> c_int;
pub type git_repository_mergehead_foreach_cb =
    extern "C" fn(arg1: *git_oid, arg2: *mut c_void) -> c_int;
pub type git_repository_state_t = c_uint;
pub static GIT_REPOSITORY_STATE_NONE: c_uint = 0;
pub static GIT_REPOSITORY_STATE_MERGE: c_uint = 1;
pub static GIT_REPOSITORY_STATE_REVERT: c_uint = 2;
pub static GIT_REPOSITORY_STATE_CHERRY_PICK: c_uint = 3;
pub static GIT_REPOSITORY_STATE_BISECT: c_uint = 4;
pub static GIT_REPOSITORY_STATE_REBASE: c_uint = 5;
pub static GIT_REPOSITORY_STATE_REBASE_INTERACTIVE: c_uint = 6;
pub static GIT_REPOSITORY_STATE_REBASE_MERGE: c_uint = 7;
pub static GIT_REPOSITORY_STATE_APPLY_MAILBOX: c_uint = 8;
pub static GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE: c_uint = 9;
pub type git_treebuilder_filter_cb =
    extern "C" fn(arg1: *git_tree_entry, arg2: *mut c_void) -> c_int;
pub type git_treewalk_cb =
    extern "C" fn(arg1: *c_schar, arg2: *git_tree_entry, arg3: *mut c_void)
        -> c_int;
pub type git_treewalk_mode = c_uint;
pub static GIT_TREEWALK_PRE: c_uint = 0;
pub static GIT_TREEWALK_POST: c_uint = 1;
pub struct Struct_git_strarray {
    strings: *mut *mut c_schar,
    count: size_t,
}
pub type git_strarray = Struct_git_strarray;
pub type git_reference_foreach_cb =
    extern "C" fn(arg1: *mut git_reference, arg2: *mut c_void) -> c_int;
pub type git_reference_foreach_name_cb =
    extern "C" fn(arg1: *c_schar, arg2: *mut c_void) -> c_int;
pub type git_reference_normalize_t = c_uint;
pub static GIT_REF_FORMAT_NORMAL: c_uint = 0;
pub static GIT_REF_FORMAT_ALLOW_ONELEVEL: c_uint = 1;
pub static GIT_REF_FORMAT_REFSPEC_PATTERN: c_uint = 2;
pub static GIT_REF_FORMAT_REFSPEC_SHORTHAND: c_uint = 4;
pub type git_diff_option_t = c_uint;
pub static GIT_DIFF_NORMAL: c_uint = 0;
pub static GIT_DIFF_REVERSE: c_uint = 1;
pub static GIT_DIFF_FORCE_TEXT: c_uint = 2;
pub static GIT_DIFF_IGNORE_WHITESPACE: c_uint = 4;
pub static GIT_DIFF_IGNORE_WHITESPACE_CHANGE: c_uint = 8;
pub static GIT_DIFF_IGNORE_WHITESPACE_EOL: c_uint = 16;
pub static GIT_DIFF_IGNORE_SUBMODULES: c_uint = 32;
pub static GIT_DIFF_PATIENCE: c_uint = 64;
pub static GIT_DIFF_INCLUDE_IGNORED: c_uint = 128;
pub static GIT_DIFF_INCLUDE_UNTRACKED: c_uint = 256;
pub static GIT_DIFF_INCLUDE_UNMODIFIED: c_uint = 512;
pub static GIT_DIFF_RECURSE_UNTRACKED_DIRS: c_uint = 1024;
pub static GIT_DIFF_DISABLE_PATHSPEC_MATCH: c_uint = 2048;
pub static GIT_DIFF_DELTAS_ARE_ICASE: c_uint = 4096;
pub static GIT_DIFF_INCLUDE_UNTRACKED_CONTENT: c_uint = 8192;
pub static GIT_DIFF_SKIP_BINARY_CHECK: c_uint = 16384;
pub static GIT_DIFF_INCLUDE_TYPECHANGE: c_uint = 32768;
pub static GIT_DIFF_INCLUDE_TYPECHANGE_TREES: c_uint = 65536;
pub static GIT_DIFF_IGNORE_FILEMODE: c_uint = 131072;
pub static GIT_DIFF_RECURSE_IGNORED_DIRS: c_uint = 262144;
pub static GIT_DIFF_FAST_UNTRACKED_DIRS: c_uint = 524288;
pub static GIT_DIFF_FORCE_BINARY: c_uint = 1048576;
pub type Struct_git_diff_list = c_void;
pub type git_diff_list = Struct_git_diff_list;
pub type git_diff_flag_t = c_uint;
pub static GIT_DIFF_FLAG_BINARY: c_uint = 1;
pub static GIT_DIFF_FLAG_NOT_BINARY: c_uint = 2;
pub static GIT_DIFF_FLAG_VALID_OID: c_uint = 4;
pub type git_delta_t = c_uint;
pub static GIT_DELTA_UNMODIFIED: c_uint = 0;
pub static GIT_DELTA_ADDED: c_uint = 1;
pub static GIT_DELTA_DELETED: c_uint = 2;
pub static GIT_DELTA_MODIFIED: c_uint = 3;
pub static GIT_DELTA_RENAMED: c_uint = 4;
pub static GIT_DELTA_COPIED: c_uint = 5;
pub static GIT_DELTA_IGNORED: c_uint = 6;
pub static GIT_DELTA_UNTRACKED: c_uint = 7;
pub static GIT_DELTA_TYPECHANGE: c_uint = 8;
pub struct git_diff_file {
    oid: git_oid,
    path: *c_schar,
    size: git_off_t,
    flags: uint32_t,
    mode: uint16_t,
}
pub struct git_diff_delta {
    old_file: git_diff_file,
    new_file: git_diff_file,
    status: git_delta_t,
    similarity: uint32_t,
    flags: uint32_t,
}
pub type git_diff_notify_cb =
    extern "C" fn
        (arg1: *git_diff_list, arg2: *git_diff_delta, arg3: *c_schar,
         arg4: *mut c_void) -> c_int;
pub struct git_diff_options {
    version: c_uint,
    flags: uint32_t,
    context_lines: uint16_t,
    interhunk_lines: uint16_t,
    old_prefix: *c_schar,
    new_prefix: *c_schar,
    pathspec: git_strarray,
    max_size: git_off_t,
    notify_cb: git_diff_notify_cb,
    notify_payload: *mut c_void,
    ignore_submodules: git_submodule_ignore_t,
}
pub type git_diff_file_cb =
    extern "C" fn(arg1: *git_diff_delta, arg2: c_float, arg3: *mut c_void)
        -> c_int;
pub struct git_diff_range {
    old_start: c_int,
    old_lines: c_int,
    new_start: c_int,
    new_lines: c_int,
}
pub type git_diff_hunk_cb =
    extern "C" fn
        (arg1: *git_diff_delta, arg2: *git_diff_range, arg3: *c_schar,
         arg4: size_t, arg5: *mut c_void) -> c_int;
pub type git_diff_line_t = c_uint;
pub static GIT_DIFF_LINE_CONTEXT: c_uint = 32;
pub static GIT_DIFF_LINE_ADDITION: c_uint = 43;
pub static GIT_DIFF_LINE_DELETION: c_uint = 45;
pub static GIT_DIFF_LINE_CONTEXT_EOFNL: c_uint = 61;
pub static GIT_DIFF_LINE_ADD_EOFNL: c_uint = 62;
pub static GIT_DIFF_LINE_DEL_EOFNL: c_uint = 60;
pub static GIT_DIFF_LINE_FILE_HDR: c_uint = 70;
pub static GIT_DIFF_LINE_HUNK_HDR: c_uint = 72;
pub static GIT_DIFF_LINE_BINARY: c_uint = 66;
pub type git_diff_data_cb =
    extern "C" fn
        (arg1: *git_diff_delta, arg2: *git_diff_range, arg3: c_schar,
         arg4: *c_schar, arg5: size_t, arg6: *mut c_void) -> c_int;
pub type Struct_git_diff_patch = c_void;
pub type git_diff_patch = Struct_git_diff_patch;
pub type git_diff_find_t = c_uint;
pub static GIT_DIFF_FIND_RENAMES: c_uint = 1;
pub static GIT_DIFF_FIND_RENAMES_FROM_REWRITES: c_uint = 2;
pub static GIT_DIFF_FIND_COPIES: c_uint = 4;
pub static GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED: c_uint = 8;
pub static GIT_DIFF_FIND_REWRITES: c_uint = 16;
pub static GIT_DIFF_BREAK_REWRITES: c_uint = 32;
pub static GIT_DIFF_FIND_AND_BREAK_REWRITES: c_uint = 48;
pub static GIT_DIFF_FIND_FOR_UNTRACKED: c_uint = 64;
pub static GIT_DIFF_FIND_ALL: c_uint = 255;
pub static GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE: c_uint = 0;
pub static GIT_DIFF_FIND_IGNORE_WHITESPACE: c_uint = 4096;
pub static GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE: c_uint = 8192;
pub static GIT_DIFF_FIND_EXACT_MATCH_ONLY: c_uint = 16384;
pub static GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY: c_uint = 32768;
pub struct git_diff_similarity_metric {
    file_signature: extern "C" fn
                        (arg1: *mut *mut c_void, arg2: *git_diff_file,
                         arg3: *c_schar, arg4: *mut c_void) -> c_int,
    buffer_signature: extern "C" fn
                          (arg1: *mut *mut c_void, arg2: *git_diff_file,
                           arg3: *c_schar, arg4: size_t, arg5: *mut c_void)
                          -> c_int,
    free_signature: extern "C" fn(arg1: *mut c_void, arg2: *mut c_void),
    similarity: extern "C" fn
                    (arg1: *mut c_int, arg2: *mut c_void, arg3: *mut c_void,
                     arg4: *mut c_void) -> c_int,
    payload: *mut c_void,
}
pub struct git_diff_find_options {
    version: c_uint,
    flags: uint32_t,
    rename_threshold: uint16_t,
    rename_from_rewrite_threshold: uint16_t,
    copy_threshold: uint16_t,
    break_rewrite_threshold: uint16_t,
    rename_limit: size_t,
    metric: *mut git_diff_similarity_metric,
}
pub type git_checkout_strategy_t = c_uint;
pub static GIT_CHECKOUT_NONE: c_uint = 0;
pub static GIT_CHECKOUT_SAFE: c_uint = 1;
pub static GIT_CHECKOUT_SAFE_CREATE: c_uint = 2;
pub static GIT_CHECKOUT_FORCE: c_uint = 4;
pub static GIT_CHECKOUT_ALLOW_CONFLICTS: c_uint = 16;
pub static GIT_CHECKOUT_REMOVE_UNTRACKED: c_uint = 32;
pub static GIT_CHECKOUT_REMOVE_IGNORED: c_uint = 64;
pub static GIT_CHECKOUT_UPDATE_ONLY: c_uint = 128;
pub static GIT_CHECKOUT_DONT_UPDATE_INDEX: c_uint = 256;
pub static GIT_CHECKOUT_NO_REFRESH: c_uint = 512;
pub static GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH: c_uint = 8192;
pub static GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES: c_uint = 262144;
pub static GIT_CHECKOUT_SKIP_UNMERGED: c_uint = 1024;
pub static GIT_CHECKOUT_USE_OURS: c_uint = 2048;
pub static GIT_CHECKOUT_USE_THEIRS: c_uint = 4096;
pub static GIT_CHECKOUT_UPDATE_SUBMODULES: c_uint = 65536;
pub static GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED: c_uint = 131072;
pub type git_checkout_notify_t = c_uint;
pub static GIT_CHECKOUT_NOTIFY_NONE: c_uint = 0;
pub static GIT_CHECKOUT_NOTIFY_CONFLICT: c_uint = 1;
pub static GIT_CHECKOUT_NOTIFY_DIRTY: c_uint = 2;
pub static GIT_CHECKOUT_NOTIFY_UPDATED: c_uint = 4;
pub static GIT_CHECKOUT_NOTIFY_UNTRACKED: c_uint = 8;
pub static GIT_CHECKOUT_NOTIFY_IGNORED: c_uint = 16;
pub static GIT_CHECKOUT_NOTIFY_ALL: c_uint = 65535;
pub type git_checkout_notify_cb =
    extern "C" fn
        (arg1: git_checkout_notify_t, arg2: *c_schar, arg3: *git_diff_file,
         arg4: *git_diff_file, arg5: *git_diff_file, arg6: *mut c_void)
        -> c_int;
pub type git_checkout_progress_cb =
    extern "C" fn
        (arg1: *c_schar, arg2: size_t, arg3: size_t, arg4: *mut c_void);
pub struct Struct_git_checkout_opts {
    version: c_uint,
    checkout_strategy: c_uint,
    disable_filters: c_int,
    dir_mode: c_uint,
    file_mode: c_uint,
    file_open_flags: c_int,
    notify_flags: c_uint,
    notify_cb: git_checkout_notify_cb,
    notify_payload: *mut c_void,
    progress_cb: git_checkout_progress_cb,
    progress_payload: *mut c_void,
    paths: git_strarray,
    baseline: *mut git_tree,
    target_directory: *c_schar,
}
pub type git_checkout_opts = Struct_git_checkout_opts;
pub type Struct_git_indexer_stream = c_void;
pub type git_indexer_stream = Struct_git_indexer_stream;
pub struct git_index_time {
    seconds: git_time_t,
    nanoseconds: c_uint,
}
pub struct Struct_git_index_entry {
    ctime: git_index_time,
    mtime: git_index_time,
    dev: c_uint,
    ino: c_uint,
    mode: c_uint,
    uid: c_uint,
    gid: c_uint,
    file_size: git_off_t,
    oid: git_oid,
    flags: c_ushort,
    flags_extended: c_ushort,
    path: *mut c_schar,
}
pub type git_index_entry = Struct_git_index_entry;
pub type git_indexcap_t = c_uint;
pub static GIT_INDEXCAP_IGNORE_CASE: c_uint = 1;
pub static GIT_INDEXCAP_NO_FILEMODE: c_uint = 2;
pub static GIT_INDEXCAP_NO_SYMLINKS: c_uint = 4;
pub static GIT_INDEXCAP_FROM_OWNER: c_uint = -1;
pub type git_index_matched_path_cb =
    extern "C" fn(arg1: *c_schar, arg2: *c_schar, arg3: *mut c_void) -> c_int;
pub type git_index_add_option_t = c_uint;
pub static GIT_INDEX_ADD_DEFAULT: c_uint = 0;
pub static GIT_INDEX_ADD_FORCE: c_uint = 1;
pub static GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH: c_uint = 2;
pub static GIT_INDEX_ADD_CHECK_PATHSPEC: c_uint = 4;
pub type git_merge_tree_flag_t = c_uint;
pub static GIT_MERGE_TREE_FIND_RENAMES: c_uint = 1;
pub type git_merge_automerge_flags = c_uint;
pub static GIT_MERGE_AUTOMERGE_NORMAL: c_uint = 0;
pub static GIT_MERGE_AUTOMERGE_NONE: c_uint = 1;
pub static GIT_MERGE_AUTOMERGE_FAVOR_OURS: c_uint = 2;
pub static GIT_MERGE_AUTOMERGE_FAVOR_THEIRS: c_uint = 3;
pub struct git_merge_tree_opts {
    version: c_uint,
    flags: git_merge_tree_flag_t,
    rename_threshold: c_uint,
    target_limit: c_uint,
    metric: *mut git_diff_similarity_metric,
    automerge_flags: git_merge_automerge_flags,
}
pub type git_revparse_mode_t = c_uint;
pub static GIT_REVPARSE_SINGLE: c_uint = 1;
pub static GIT_REVPARSE_RANGE: c_uint = 2;
pub static GIT_REVPARSE_MERGE_BASE: c_uint = 4;
pub struct git_revspec {
    from: *mut git_object,
    to: *mut git_object,
    flags: c_uint,
}
pub type git_blob_chunk_cb =
    extern "C" fn(arg1: *mut c_schar, arg2: size_t, arg3: *mut c_void)
        -> c_int;
pub type git_tag_foreach_cb =
    extern "C" fn(arg1: *c_schar, arg2: *mut git_oid, arg3: *mut c_void)
        -> c_int;
pub type git_config_level_t = c_int;
pub static GIT_CONFIG_LEVEL_SYSTEM: c_int = 1;
pub static GIT_CONFIG_LEVEL_XDG: c_int = 2;
pub static GIT_CONFIG_LEVEL_GLOBAL: c_int = 3;
pub static GIT_CONFIG_LEVEL_LOCAL: c_int = 4;
pub static GIT_CONFIG_LEVEL_APP: c_int = 5;
pub static GIT_CONFIG_HIGHEST_LEVEL: c_int = -1;
pub struct git_config_entry {
    name: *c_schar,
    value: *c_schar,
    level: git_config_level_t,
}
pub type git_config_foreach_cb =
    extern "C" fn(arg1: *git_config_entry, arg2: *mut c_void) -> c_int;
pub type Struct_git_config_iterator = c_void;
pub type git_config_iterator = Struct_git_config_iterator;
pub type git_cvar_t = c_uint;
pub static GIT_CVAR_FALSE: c_uint = 0;
pub static GIT_CVAR_TRUE: c_uint = 1;
pub static GIT_CVAR_INT32: c_uint = 2;
pub static GIT_CVAR_STRING: c_uint = 3;
pub struct git_cvar_map {
    cvar_type: git_cvar_t,
    str_match: *c_schar,
    map_value: c_int,
}
pub type git_direction = c_uint;
pub static GIT_DIRECTION_FETCH: c_uint = 0;
pub static GIT_DIRECTION_PUSH: c_uint = 1;
pub struct Struct_git_remote_head {
    local: c_int,
    oid: git_oid,
    loid: git_oid,
    name: *mut c_schar,
}
pub type git_headlist_cb =
    extern "C" fn(arg1: *mut git_remote_head, arg2: *mut c_void) -> c_int;
pub type git_credtype_t = c_uint;
pub static GIT_CREDTYPE_USERPASS_PLAINTEXT: c_uint = 1;
pub static GIT_CREDTYPE_SSH_KEYFILE_PASSPHRASE: c_uint = 2;
pub static GIT_CREDTYPE_SSH_PUBLICKEY: c_uint = 3;
pub type git_cred = Struct_git_cred;
pub struct Struct_git_cred {
    credtype: git_credtype_t,
    free: extern "C" fn(arg1: *mut git_cred),
}
pub struct git_cred_userpass_plaintext {
    parent: git_cred,
    username: *mut c_schar,
    password: *mut c_schar,
}
pub type git_cred_sign_callback = extern "C" fn(arg1: *mut c_void) -> c_int;
pub struct Struct_git_cred_ssh_keyfile_passphrase {
    parent: git_cred,
    username: *mut c_schar,
    publickey: *mut c_schar,
    privatekey: *mut c_schar,
    passphrase: *mut c_schar,
}
pub type git_cred_ssh_keyfile_passphrase =
    Struct_git_cred_ssh_keyfile_passphrase;
pub struct Struct_git_cred_ssh_publickey {
    parent: git_cred,
    username: *mut c_schar,
    publickey: *mut c_schar,
    publickey_len: size_t,
    sign_callback: *mut c_void,
    sign_data: *mut c_void,
}
pub type git_cred_ssh_publickey = Struct_git_cred_ssh_publickey;
pub type git_cred_acquire_cb =
    extern "C" fn
        (arg1: *mut *mut git_cred, arg2: *c_schar, arg3: *c_schar,
         arg4: c_uint, arg5: *mut c_void) -> c_int;
pub type git_transport_flags_t = c_uint;
pub static GIT_TRANSPORTFLAGS_NONE: c_uint = 0;
pub static GIT_TRANSPORTFLAGS_NO_CHECK_CERT: c_uint = 1;
pub type git_transport_message_cb =
    extern "C" fn(arg1: *c_schar, arg2: c_int, arg3: *mut c_void);
pub type git_transport = Struct_git_transport;
pub struct Struct_git_transport {
    version: c_uint,
    set_callbacks: extern "C" fn
                       (arg1: *mut git_transport,
                        arg2: git_transport_message_cb,
                        arg3: git_transport_message_cb, arg4: *mut c_void)
                       -> c_int,
    connect: extern "C" fn
                 (arg1: *mut git_transport, arg2: *c_schar,
                  arg3: git_cred_acquire_cb, arg4: *mut c_void, arg5: c_int,
                  arg6: c_int) -> c_int,
    ls: extern "C" fn
            (arg1: *mut git_transport, arg2: git_headlist_cb,
             arg3: *mut c_void) -> c_int,
    push: extern "C" fn(arg1: *mut git_transport, arg2: *mut git_push)
              -> c_int,
    negotiate_fetch: extern "C" fn
                         (arg1: *mut git_transport, arg2: *mut git_repository,
                          arg3: **git_remote_head, arg4: size_t) -> c_int,
    download_pack: extern "C" fn
                       (arg1: *mut git_transport, arg2: *mut git_repository,
                        arg3: *mut git_transfer_progress,
                        arg4: git_transfer_progress_callback,
                        arg5: *mut c_void) -> c_int,
    is_connected: extern "C" fn(arg1: *mut git_transport) -> c_int,
    read_flags: extern "C" fn(arg1: *mut git_transport, arg2: *mut c_int)
                    -> c_int,
    cancel: extern "C" fn(arg1: *mut git_transport),
    close: extern "C" fn(arg1: *mut git_transport) -> c_int,
    free: extern "C" fn(arg1: *mut git_transport),
}
pub type git_transport_cb =
    extern "C" fn
        (arg1: *mut *mut git_transport, arg2: *mut git_remote,
         arg3: *mut c_void) -> c_int;
pub type git_smart_service_t = c_uint;
pub static GIT_SERVICE_UPLOADPACK_LS: c_uint = 1;
pub static GIT_SERVICE_UPLOADPACK: c_uint = 2;
pub static GIT_SERVICE_RECEIVEPACK_LS: c_uint = 3;
pub static GIT_SERVICE_RECEIVEPACK: c_uint = 4;
pub type git_smart_subtransport = Struct_git_smart_subtransport;
pub type git_smart_subtransport_stream = Struct_git_smart_subtransport_stream;
pub struct Struct_git_smart_subtransport_stream {
    subtransport: *mut git_smart_subtransport,
    read: extern "C" fn
              (arg1: *mut git_smart_subtransport_stream, arg2: *mut c_schar,
               arg3: size_t, arg4: *mut size_t) -> c_int,
    write: extern "C" fn
               (arg1: *mut git_smart_subtransport_stream, arg2: *c_schar,
                arg3: size_t) -> c_int,
    free: extern "C" fn(arg1: *mut git_smart_subtransport_stream),
}
pub struct Struct_git_smart_subtransport {
    action: extern "C" fn
                (arg1: *mut *mut git_smart_subtransport_stream,
                 arg2: *mut git_smart_subtransport, arg3: *c_schar,
                 arg4: git_smart_service_t) -> c_int,
    close: extern "C" fn(arg1: *mut git_smart_subtransport) -> c_int,
    free: extern "C" fn(arg1: *mut git_smart_subtransport),
}
pub type git_smart_subtransport_cb =
    extern "C" fn
        (arg1: *mut *mut git_smart_subtransport, arg2: *mut git_transport)
        -> c_int;
pub struct Struct_git_smart_subtransport_definition {
    callback: git_smart_subtransport_cb,
    rpc: c_uint,
}
pub type git_smart_subtransport_definition =
    Struct_git_smart_subtransport_definition;
pub type git_remote_rename_problem_cb =
    extern "C" fn(arg1: *c_schar, arg2: *mut c_void) -> c_int;
pub type Enum_git_remote_completion_type = c_uint;
pub static GIT_REMOTE_COMPLETION_DOWNLOAD: c_uint = 0;
pub static GIT_REMOTE_COMPLETION_INDEXING: c_uint = 1;
pub static GIT_REMOTE_COMPLETION_ERROR: c_uint = 2;
pub type git_remote_completion_type = Enum_git_remote_completion_type;
pub struct Struct_git_remote_callbacks {
    version: c_uint,
    progress: extern "C" fn(arg1: *c_schar, arg2: c_int, arg3: *mut c_void),
    completion: extern "C" fn
                    (arg1: git_remote_completion_type, arg2: *mut c_void)
                    -> c_int,
    update_tips: extern "C" fn
                     (arg1: *c_schar, arg2: *git_oid, arg3: *git_oid,
                      arg4: *mut c_void) -> c_int,
    payload: *mut c_void,
}
pub type git_remote_autotag_option_t = c_uint;
pub static GIT_REMOTE_DOWNLOAD_TAGS_AUTO: c_uint = 0;
pub static GIT_REMOTE_DOWNLOAD_TAGS_NONE: c_uint = 1;
pub static GIT_REMOTE_DOWNLOAD_TAGS_ALL: c_uint = 2;
pub struct Struct_git_clone_options {
    version: c_uint,
    checkout_opts: git_checkout_opts,
    bare: c_int,
    fetch_progress_cb: git_transfer_progress_callback,
    fetch_progress_payload: *mut c_void,
    remote_name: *c_schar,
    pushurl: *c_schar,
    fetch_spec: *c_schar,
    push_spec: *c_schar,
    cred_acquire_cb: git_cred_acquire_cb,
    cred_acquire_payload: *mut c_void,
    transport_flags: git_transport_flags_t,
    transport: *mut git_transport,
    remote_callbacks: *mut git_remote_callbacks,
    remote_autotag: git_remote_autotag_option_t,
    checkout_branch: *c_schar,
}
pub type git_clone_options = Struct_git_clone_options;
pub struct git_push_options {
    version: c_uint,
    pb_parallelism: c_uint,
}
pub type git_attr_t = c_uint;
pub static GIT_ATTR_UNSPECIFIED_T: c_uint = 0;
pub static GIT_ATTR_TRUE_T: c_uint = 1;
pub static GIT_ATTR_FALSE_T: c_uint = 2;
pub static GIT_ATTR_VALUE_T: c_uint = 3;
pub type git_attr_foreach_cb =
    extern "C" fn(arg1: *c_schar, arg2: *c_schar, arg3: *mut c_void) -> c_int;
pub type git_branch_foreach_cb =
    extern "C" fn(arg1: *c_schar, arg2: git_branch_t, arg3: *mut c_void)
        -> c_int;
pub type git_status_t = c_uint;
pub static GIT_STATUS_CURRENT: c_uint = 0;
pub static GIT_STATUS_INDEX_NEW: c_uint = 1;
pub static GIT_STATUS_INDEX_MODIFIED: c_uint = 2;
pub static GIT_STATUS_INDEX_DELETED: c_uint = 4;
pub static GIT_STATUS_INDEX_RENAMED: c_uint = 8;
pub static GIT_STATUS_INDEX_TYPECHANGE: c_uint = 16;
pub static GIT_STATUS_WT_NEW: c_uint = 128;
pub static GIT_STATUS_WT_MODIFIED: c_uint = 256;
pub static GIT_STATUS_WT_DELETED: c_uint = 512;
pub static GIT_STATUS_WT_TYPECHANGE: c_uint = 1024;
pub static GIT_STATUS_WT_RENAMED: c_uint = 2048;
pub static GIT_STATUS_IGNORED: c_uint = 16384;
pub type git_status_cb =
    extern "C" fn(arg1: *c_schar, arg2: c_uint, arg3: *mut c_void) -> c_int;
pub type git_status_show_t = c_uint;
pub static GIT_STATUS_SHOW_INDEX_AND_WORKDIR: c_uint = 0;
pub static GIT_STATUS_SHOW_INDEX_ONLY: c_uint = 1;
pub static GIT_STATUS_SHOW_WORKDIR_ONLY: c_uint = 2;
pub type git_status_opt_t = c_uint;
pub static GIT_STATUS_OPT_INCLUDE_UNTRACKED: c_uint = 1;
pub static GIT_STATUS_OPT_INCLUDE_IGNORED: c_uint = 2;
pub static GIT_STATUS_OPT_INCLUDE_UNMODIFIED: c_uint = 4;
pub static GIT_STATUS_OPT_EXCLUDE_SUBMODULES: c_uint = 8;
pub static GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS: c_uint = 16;
pub static GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH: c_uint = 32;
pub static GIT_STATUS_OPT_RECURSE_IGNORED_DIRS: c_uint = 64;
pub static GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX: c_uint = 128;
pub static GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR: c_uint = 256;
pub static GIT_STATUS_OPT_SORT_CASE_SENSITIVELY: c_uint = 512;
pub static GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY: c_uint = 1024;
pub static GIT_STATUS_OPT_RENAMES_FROM_REWRITES: c_uint = 2048;
pub struct git_status_options {
    version: c_uint,
    show: git_status_show_t,
    flags: c_uint,
    pathspec: git_strarray,
}
pub struct git_status_entry {
    status: git_status_t,
    head_to_index: *mut git_diff_delta,
    index_to_workdir: *mut git_diff_delta,
}
pub type git_submodule_status_t = c_uint;
pub static GIT_SUBMODULE_STATUS_IN_HEAD: c_uint = 1;
pub static GIT_SUBMODULE_STATUS_IN_INDEX: c_uint = 2;
pub static GIT_SUBMODULE_STATUS_IN_CONFIG: c_uint = 4;
pub static GIT_SUBMODULE_STATUS_IN_WD: c_uint = 8;
pub static GIT_SUBMODULE_STATUS_INDEX_ADDED: c_uint = 16;
pub static GIT_SUBMODULE_STATUS_INDEX_DELETED: c_uint = 32;
pub static GIT_SUBMODULE_STATUS_INDEX_MODIFIED: c_uint = 64;
pub static GIT_SUBMODULE_STATUS_WD_UNINITIALIZED: c_uint = 128;
pub static GIT_SUBMODULE_STATUS_WD_ADDED: c_uint = 256;
pub static GIT_SUBMODULE_STATUS_WD_DELETED: c_uint = 512;
pub static GIT_SUBMODULE_STATUS_WD_MODIFIED: c_uint = 1024;
pub static GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED: c_uint = 2048;
pub static GIT_SUBMODULE_STATUS_WD_WD_MODIFIED: c_uint = 4096;
pub static GIT_SUBMODULE_STATUS_WD_UNTRACKED: c_uint = 8192;
pub type git_note_foreach_cb =
    extern "C" fn(arg1: *git_oid, arg2: *git_oid, arg3: *mut c_void) -> c_int;
pub type Struct_git_iterator = c_void;
pub type git_note_iterator = Struct_git_iterator;
pub type git_reset_t = c_uint;
pub static GIT_RESET_SOFT: c_uint = 1;
pub static GIT_RESET_MIXED: c_uint = 2;
pub static GIT_RESET_HARD: c_uint = 3;
pub type git_packbuilder_foreach_cb =
    extern "C" fn(arg1: *mut c_void, arg2: size_t, arg3: *mut c_void)
        -> c_int;
pub type git_stash_flags = c_uint;
pub static GIT_STASH_DEFAULT: c_uint = 0;
pub static GIT_STASH_KEEP_INDEX: c_uint = 1;
pub static GIT_STASH_INCLUDE_UNTRACKED: c_uint = 2;
pub static GIT_STASH_INCLUDE_IGNORED: c_uint = 4;
pub type git_stash_cb =
    extern "C" fn
        (arg1: size_t, arg2: *c_schar, arg3: *git_oid, arg4: *mut c_void)
        -> c_int;
pub type Struct_git_pathspec = c_void;
pub type git_pathspec = Struct_git_pathspec;
pub type Struct_git_pathspec_match_list = c_void;
pub type git_pathspec_match_list = Struct_git_pathspec_match_list;
pub type git_pathspec_flag_t = c_uint;
pub static GIT_PATHSPEC_DEFAULT: c_uint = 0;
pub static GIT_PATHSPEC_IGNORE_CASE: c_uint = 1;
pub static GIT_PATHSPEC_USE_CASE: c_uint = 2;
pub static GIT_PATHSPEC_NO_GLOB: c_uint = 4;
pub static GIT_PATHSPEC_NO_MATCH_ERROR: c_uint = 8;
pub static GIT_PATHSPEC_FIND_FAILURES: c_uint = 16;
pub static GIT_PATHSPEC_FAILURES_ONLY: c_uint = 32;
extern "C" {
    pub static mut __tzname: [*mut c_schar, ..2u];
    pub static mut __daylight: c_int;
    pub static mut __timezone: c_long;
    pub static mut tzname: [*mut c_schar, ..2u];
    pub static mut daylight: c_int;
    pub static mut timezone: c_long;
    pub fn clock() -> clock_t;
    pub fn time(__timer: *mut time_t) -> time_t;
    pub fn difftime(__time1: time_t, __time0: time_t) -> c_double;
    pub fn mktime(__tp: *mut Struct_tm) -> time_t;
    pub fn strftime(__s: *mut c_schar, __maxsize: size_t, __format: *c_schar,
                    __tp: *Struct_tm) -> size_t;
    pub fn strftime_l(__s: *mut c_schar, __maxsize: size_t,
                      __format: *c_schar, __tp: *Struct_tm, __loc: __locale_t)
     -> size_t;
    pub fn gmtime(__timer: *time_t) -> *mut Struct_tm;
    pub fn localtime(__timer: *time_t) -> *mut Struct_tm;
    pub fn gmtime_r(__timer: *time_t, __tp: *mut Struct_tm) -> *mut Struct_tm;
    pub fn localtime_r(__timer: *time_t, __tp: *mut Struct_tm) ->
     *mut Struct_tm;
    pub fn asctime(__tp: *Struct_tm) -> *mut c_schar;
    pub fn ctime(__timer: *time_t) -> *mut c_schar;
    pub fn asctime_r(__tp: *Struct_tm, __buf: *mut c_schar) -> *mut c_schar;
    pub fn ctime_r(__timer: *time_t, __buf: *mut c_schar) -> *mut c_schar;
    pub fn tzset();
    pub fn stime(__when: *time_t) -> c_int;
    pub fn timegm(__tp: *mut Struct_tm) -> time_t;
    pub fn timelocal(__tp: *mut Struct_tm) -> time_t;
    pub fn dysize(__year: c_int) -> c_int;
    pub fn nanosleep(__requested_time: *Struct_timespec,
                     __remaining: *mut Struct_timespec) -> c_int;
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut Struct_timespec) ->
     c_int;
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut Struct_timespec) ->
     c_int;
    pub fn clock_settime(__clock_id: clockid_t, __tp: *Struct_timespec) ->
     c_int;
    pub fn clock_nanosleep(__clock_id: clockid_t, __flags: c_int,
                           __req: *Struct_timespec,
                           __rem: *mut Struct_timespec) -> c_int;
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) ->
     c_int;
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut Struct_sigevent,
                        __timerid: *mut timer_t) -> c_int;
    pub fn timer_delete(__timerid: timer_t) -> c_int;
    pub fn timer_settime(__timerid: timer_t, __flags: c_int,
                         __value: *Struct_itimerspec,
                         __ovalue: *mut Struct_itimerspec) -> c_int;
    pub fn timer_gettime(__timerid: timer_t, __value: *mut Struct_itimerspec)
     -> c_int;
    pub fn timer_getoverrun(__timerid: timer_t) -> c_int;
    pub fn __ctype_get_mb_cur_max() -> size_t;
    pub fn atof(__nptr: *c_schar) -> c_double;
    pub fn atoi(__nptr: *c_schar) -> c_int;
    pub fn atol(__nptr: *c_schar) -> c_long;
    pub fn atoll(__nptr: *c_schar) -> c_longlong;
    pub fn strtod(__nptr: *c_schar, __endptr: *mut *mut c_schar) -> c_double;
    pub fn strtof(__nptr: *c_schar, __endptr: *mut *mut c_schar) -> c_float;
    pub fn strtold(__nptr: *c_schar, __endptr: *mut *mut c_schar) -> c_double;
    pub fn strtol(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                  __base: c_int) -> c_long;
    pub fn strtoul(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                   __base: c_int) -> c_ulong;
    pub fn strtoq(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                  __base: c_int) -> c_longlong;
    pub fn strtouq(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                   __base: c_int) -> c_ulonglong;
    pub fn strtoll(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                   __base: c_int) -> c_longlong;
    pub fn strtoull(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                    __base: c_int) -> c_ulonglong;
    pub fn l64a(__n: c_long) -> *mut c_schar;
    pub fn a64l(__s: *c_schar) -> c_long;
    pub fn select(__nfds: c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut Struct_timeval) -> c_int;
    pub fn pselect(__nfds: c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *Struct_timespec, __sigmask: *__sigset_t) ->
     c_int;
    pub fn gnu_dev_major(__dev: c_ulonglong) -> c_uint;
    pub fn gnu_dev_minor(__dev: c_ulonglong) -> c_uint;
    pub fn gnu_dev_makedev(__major: c_uint, __minor: c_uint) -> c_ulonglong;
    pub fn random() -> c_long;
    pub fn srandom(__seed: c_uint);
    pub fn initstate(__seed: c_uint, __statebuf: *mut c_schar,
                     __statelen: size_t) -> *mut c_schar;
    pub fn setstate(__statebuf: *mut c_schar) -> *mut c_schar;
    pub fn random_r(__buf: *mut Struct_random_data, __result: *mut int32_t) ->
     c_int;
    pub fn srandom_r(__seed: c_uint, __buf: *mut Struct_random_data) -> c_int;
    pub fn initstate_r(__seed: c_uint, __statebuf: *mut c_schar,
                       __statelen: size_t, __buf: *mut Struct_random_data) ->
     c_int;
    pub fn setstate_r(__statebuf: *mut c_schar,
                      __buf: *mut Struct_random_data) -> c_int;
    pub fn rand() -> c_int;
    pub fn srand(__seed: c_uint);
    pub fn rand_r(__seed: *mut c_uint) -> c_int;
    pub fn drand48() -> c_double;
    pub fn erand48(__xsubi: *mut c_ushort) -> c_double;
    pub fn lrand48() -> c_long;
    pub fn nrand48(__xsubi: *mut c_ushort) -> c_long;
    pub fn mrand48() -> c_long;
    pub fn jrand48(__xsubi: *mut c_ushort) -> c_long;
    pub fn srand48(__seedval: c_long);
    pub fn seed48(__seed16v: *mut c_ushort) -> *mut c_ushort;
    pub fn lcong48(__param: *mut c_ushort);
    pub fn drand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut c_double) -> c_int;
    pub fn erand48_r(__xsubi: *mut c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut c_double) -> c_int;
    pub fn lrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn nrand48_r(__xsubi: *mut c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn mrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn jrand48_r(__xsubi: *mut c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut c_long) -> c_int;
    pub fn srand48_r(__seedval: c_long, __buffer: *mut Struct_drand48_data) ->
     c_int;
    pub fn seed48_r(__seed16v: *mut c_ushort,
                    __buffer: *mut Struct_drand48_data) -> c_int;
    pub fn lcong48_r(__param: *mut c_ushort,
                     __buffer: *mut Struct_drand48_data) -> c_int;
    pub fn malloc(__size: size_t) -> *mut c_void;
    pub fn calloc(__nmemb: size_t, __size: size_t) -> *mut c_void;
    pub fn realloc(__ptr: *mut c_void, __size: size_t) -> *mut c_void;
    pub fn free(__ptr: *mut c_void);
    pub fn cfree(__ptr: *mut c_void);
    pub fn alloca(__size: size_t) -> *mut c_void;
    pub fn valloc(__size: size_t) -> *mut c_void;
    pub fn posix_memalign(__memptr: *mut *mut c_void, __alignment: size_t,
                          __size: size_t) -> c_int;
    pub fn abort();
    pub fn atexit(__func: extern "C" fn()) -> c_int;
    pub fn on_exit(__func: extern "C" fn(arg1: c_int, arg2: *mut c_void),
                   __arg: *mut c_void) -> c_int;
    pub fn exit(__status: c_int);
    pub fn _Exit(__status: c_int);
    pub fn getenv(__name: *c_schar) -> *mut c_schar;
    pub fn putenv(__string: *mut c_schar) -> c_int;
    pub fn setenv(__name: *c_schar, __value: *c_schar, __replace: c_int) ->
     c_int;
    pub fn unsetenv(__name: *c_schar) -> c_int;
    pub fn clearenv() -> c_int;
    pub fn mktemp(__template: *mut c_schar) -> *mut c_schar;
    pub fn mkstemp(__template: *mut c_schar) -> c_int;
    pub fn mkstemps(__template: *mut c_schar, __suffixlen: c_int) -> c_int;
    pub fn mkdtemp(__template: *mut c_schar) -> *mut c_schar;
    pub fn system(__command: *c_schar) -> c_int;
    pub fn realpath(__name: *c_schar, __resolved: *mut c_schar) ->
     *mut c_schar;
    pub fn bsearch(__key: *c_void, __base: *c_void, __nmemb: size_t,
                   __size: size_t, __compar: __compar_fn_t) -> *mut c_void;
    pub fn qsort(__base: *mut c_void, __nmemb: size_t, __size: size_t,
                 __compar: __compar_fn_t);
    pub fn abs(__x: c_int) -> c_int;
    pub fn labs(__x: c_long) -> c_long;
    pub fn llabs(__x: c_longlong) -> c_longlong;
    pub fn div(__numer: c_int, __denom: c_int) -> div_t;
    pub fn ldiv(__numer: c_long, __denom: c_long) -> ldiv_t;
    pub fn lldiv(__numer: c_longlong, __denom: c_longlong) -> lldiv_t;
    pub fn ecvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                __sign: *mut c_int) -> *mut c_schar;
    pub fn fcvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                __sign: *mut c_int) -> *mut c_schar;
    pub fn gcvt(__value: c_double, __ndigit: c_int, __buf: *mut c_schar) ->
     *mut c_schar;
    pub fn qecvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                 __sign: *mut c_int) -> *mut c_schar;
    pub fn qfcvt(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                 __sign: *mut c_int) -> *mut c_schar;
    pub fn qgcvt(__value: c_double, __ndigit: c_int, __buf: *mut c_schar) ->
     *mut c_schar;
    pub fn ecvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                  __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn fcvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                  __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn qecvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                   __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn qfcvt_r(__value: c_double, __ndigit: c_int, __decpt: *mut c_int,
                   __sign: *mut c_int, __buf: *mut c_schar, __len: size_t) ->
     c_int;
    pub fn mblen(__s: *c_schar, __n: size_t) -> c_int;
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *c_schar, __n: size_t) -> c_int;
    pub fn wctomb(__s: *mut c_schar, __wchar: wchar_t) -> c_int;
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *c_schar, __n: size_t) ->
     size_t;
    pub fn wcstombs(__s: *mut c_schar, __pwcs: *wchar_t, __n: size_t) ->
     size_t;
    pub fn rpmatch(__response: *c_schar) -> c_int;
    pub fn getsubopt(__optionp: *mut *mut c_schar, __tokens: **mut c_schar,
                     __valuep: *mut *mut c_schar) -> c_int;
    pub fn getloadavg(__loadavg: *mut c_double, __nelem: c_int) -> c_int;
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
    pub fn strtoimax(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                     __base: c_int) -> intmax_t;
    pub fn strtoumax(__nptr: *c_schar, __endptr: *mut *mut c_schar,
                     __base: c_int) -> uintmax_t;
    pub fn wcstoimax(__nptr: *__gwchar_t, __endptr: *mut *mut __gwchar_t,
                     __base: c_int) -> intmax_t;
    pub fn wcstoumax(__nptr: *__gwchar_t, __endptr: *mut *mut __gwchar_t,
                     __base: c_int) -> uintmax_t;
    pub fn git_libgit2_version(major: *mut c_int, minor: *mut c_int,
                               rev: *mut c_int);
    pub fn git_libgit2_capabilities() -> c_int;
    pub fn git_libgit2_opts(option: c_int) -> c_int;
    pub fn git_threads_init() -> c_int;
    pub fn git_threads_shutdown();
    pub fn giterr_last() -> *git_error;
    pub fn giterr_clear();
    pub fn giterr_set_str(error_class: c_int, string: *c_schar);
    pub fn giterr_set_oom();
    pub fn git_oid_fromstr(out: *mut git_oid, str: *c_schar) -> c_int;
    pub fn git_oid_fromstrp(out: *mut git_oid, str: *c_schar) -> c_int;
    pub fn git_oid_fromstrn(out: *mut git_oid, str: *c_schar, length: size_t)
     -> c_int;
    pub fn git_oid_fromraw(out: *mut git_oid, raw: *c_uchar);
    pub fn git_oid_fmt(out: *mut c_schar, id: *git_oid);
    pub fn git_oid_nfmt(out: *mut c_schar, n: size_t, id: *git_oid);
    pub fn git_oid_pathfmt(out: *mut c_schar, id: *git_oid);
    pub fn git_oid_allocfmt(id: *git_oid) -> *mut c_schar;
    pub fn git_oid_tostr(out: *mut c_schar, n: size_t, id: *git_oid) ->
     *mut c_schar;
    pub fn git_oid_cpy(out: *mut git_oid, src: *git_oid);
    pub fn git_oid_cmp(a: *git_oid, b: *git_oid) -> c_int;
    pub fn git_oid_ncmp(a: *git_oid, b: *git_oid, len: size_t) -> c_int;
    pub fn git_oid_streq(id: *git_oid, str: *c_schar) -> c_int;
    pub fn git_oid_strcmp(id: *git_oid, str: *c_schar) -> c_int;
    pub fn git_oid_iszero(id: *git_oid) -> c_int;
    pub fn git_oid_shorten_new(min_length: size_t) -> *mut git_oid_shorten;
    pub fn git_oid_shorten_add(os: *mut git_oid_shorten, text_id: *c_schar) ->
     c_int;
    pub fn git_oid_shorten_free(os: *mut git_oid_shorten);
    pub fn git_signature_new(out: *mut *mut git_signature, name: *c_schar,
                             email: *c_schar, time: git_time_t, offset: c_int)
     -> c_int;
    pub fn git_signature_now(out: *mut *mut git_signature, name: *c_schar,
                             email: *c_schar) -> c_int;
    pub fn git_signature_default(out: *mut *mut git_signature,
                                 repo: *mut git_repository) -> c_int;
    pub fn git_signature_dup(sig: *git_signature) -> *mut git_signature;
    pub fn git_signature_free(sig: *mut git_signature);
    pub fn git_odb_new(out: *mut *mut git_odb) -> c_int;
    pub fn git_odb_open(out: *mut *mut git_odb, objects_dir: *c_schar) ->
     c_int;
    pub fn git_odb_add_disk_alternate(odb: *mut git_odb, path: *c_schar) ->
     c_int;
    pub fn git_odb_free(db: *mut git_odb);
    pub fn git_odb_read(out: *mut *mut git_odb_object, db: *mut git_odb,
                        id: *git_oid) -> c_int;
    pub fn git_odb_read_prefix(out: *mut *mut git_odb_object,
                               db: *mut git_odb, short_id: *git_oid,
                               len: size_t) -> c_int;
    pub fn git_odb_read_header(len_out: *mut size_t, type_out: *mut git_otype,
                               db: *mut git_odb, id: *git_oid) -> c_int;
    pub fn git_odb_exists(db: *mut git_odb, id: *git_oid) -> c_int;
    pub fn git_odb_refresh(db: *mut Struct_git_odb) -> c_int;
    pub fn git_odb_foreach(db: *mut git_odb, cb: git_odb_foreach_cb,
                           payload: *mut c_void) -> c_int;
    pub fn git_odb_write(out: *mut git_oid, odb: *mut git_odb, data: *c_void,
                         len: size_t, _type: git_otype) -> c_int;
    pub fn git_odb_open_wstream(out: *mut *mut git_odb_stream,
                                db: *mut git_odb, size: size_t,
                                _type: git_otype) -> c_int;
    pub fn git_odb_stream_write(stream: *mut git_odb_stream, buffer: *c_schar,
                                len: size_t) -> c_int;
    pub fn git_odb_stream_finalize_write(out: *mut git_oid,
                                         stream: *mut git_odb_stream) ->
     c_int;
    pub fn git_odb_stream_read(stream: *mut git_odb_stream,
                               buffer: *mut c_schar, len: size_t) -> c_int;
    pub fn git_odb_stream_free(stream: *mut git_odb_stream);
    pub fn git_odb_open_rstream(out: *mut *mut git_odb_stream,
                                db: *mut git_odb, oid: *git_oid) -> c_int;
    pub fn git_odb_write_pack(out: *mut *mut git_odb_writepack,
                              db: *mut git_odb,
                              progress_cb: git_transfer_progress_callback,
                              progress_payload: *mut c_void) -> c_int;
    pub fn git_odb_hash(out: *mut git_oid, data: *c_void, len: size_t,
                        _type: git_otype) -> c_int;
    pub fn git_odb_hashfile(out: *mut git_oid, path: *c_schar,
                            _type: git_otype) -> c_int;
    pub fn git_odb_object_free(object: *mut git_odb_object);
    pub fn git_odb_object_id(object: *mut git_odb_object) -> *git_oid;
    pub fn git_odb_object_data(object: *mut git_odb_object) -> *c_void;
    pub fn git_odb_object_size(object: *mut git_odb_object) -> size_t;
    pub fn git_odb_object_type(object: *mut git_odb_object) -> git_otype;
    pub fn git_odb_add_backend(odb: *mut git_odb,
                               backend: *mut git_odb_backend, priority: c_int)
     -> c_int;
    pub fn git_odb_add_alternate(odb: *mut git_odb,
                                 backend: *mut git_odb_backend,
                                 priority: c_int) -> c_int;
    pub fn git_odb_num_backends(odb: *mut git_odb) -> size_t;
    pub fn git_odb_get_backend(out: *mut *mut git_odb_backend,
                               odb: *mut git_odb, pos: size_t) -> c_int;
    pub fn git_repository_open(out: *mut *mut git_repository, path: *c_schar)
     -> c_int;
    pub fn git_repository_wrap_odb(out: *mut *mut git_repository,
                                   odb: *mut git_odb) -> c_int;
    pub fn git_repository_discover(path_out: *mut c_schar, path_size: size_t,
                                   start_path: *c_schar, across_fs: c_int,
                                   ceiling_dirs: *c_schar) -> c_int;
    pub fn git_repository_open_ext(out: *mut *mut git_repository,
                                   path: *c_schar, flags: c_uint,
                                   ceiling_dirs: *c_schar) -> c_int;
    pub fn git_repository_open_bare(out: *mut *mut git_repository,
                                    bare_path: *c_schar) -> c_int;
    pub fn git_repository_free(repo: *mut git_repository);
    pub fn git_repository_init(out: *mut *mut git_repository, path: *c_schar,
                               is_bare: c_uint) -> c_int;
    pub fn git_repository_init_ext(out: *mut *mut git_repository,
                                   repo_path: *c_schar,
                                   opts: *mut git_repository_init_options) ->
     c_int;
    pub fn git_repository_head(out: *mut *mut git_reference,
                               repo: *mut git_repository) -> c_int;
    pub fn git_repository_head_detached(repo: *mut git_repository) -> c_int;
    pub fn git_repository_head_orphan(repo: *mut git_repository) -> c_int;
    pub fn git_repository_is_empty(repo: *mut git_repository) -> c_int;
    pub fn git_repository_path(repo: *mut git_repository) -> *c_schar;
    pub fn git_repository_workdir(repo: *mut git_repository) -> *c_schar;
    pub fn git_repository_set_workdir(repo: *mut git_repository,
                                      workdir: *c_schar,
                                      update_gitlink: c_int) -> c_int;
    pub fn git_repository_is_bare(repo: *mut git_repository) -> c_int;
    pub fn git_repository_config(out: *mut *mut git_config,
                                 repo: *mut git_repository) -> c_int;
    pub fn git_repository_odb(out: *mut *mut git_odb,
                              repo: *mut git_repository) -> c_int;
    pub fn git_repository_refdb(out: *mut *mut git_refdb,
                                repo: *mut git_repository) -> c_int;
    pub fn git_repository_index(out: *mut *mut git_index,
                                repo: *mut git_repository) -> c_int;
    pub fn git_repository_message(out: *mut c_schar, len: size_t,
                                  repo: *mut git_repository) -> c_int;
    pub fn git_repository_message_remove(repo: *mut git_repository) -> c_int;
    pub fn git_repository_merge_cleanup(repo: *mut git_repository) -> c_int;
    pub fn git_repository_fetchhead_foreach(repo: *mut git_repository,
                                            callback:
                                                git_repository_fetchhead_foreach_cb,
                                            payload: *mut c_void) -> c_int;
    pub fn git_repository_mergehead_foreach(repo: *mut git_repository,
                                            callback:
                                                git_repository_mergehead_foreach_cb,
                                            payload: *mut c_void) -> c_int;
    pub fn git_repository_hashfile(out: *mut git_oid,
                                   repo: *mut git_repository, path: *c_schar,
                                   _type: git_otype, as_path: *c_schar) ->
     c_int;
    pub fn git_repository_set_head(repo: *mut git_repository,
                                   refname: *c_schar) -> c_int;
    pub fn git_repository_set_head_detached(repo: *mut git_repository,
                                            commitish: *git_oid) -> c_int;
    pub fn git_repository_detach_head(repo: *mut git_repository) -> c_int;
    pub fn git_repository_state(repo: *mut git_repository) -> c_int;
    pub fn git_repository_set_namespace(repo: *mut git_repository,
                                        nmspace: *c_schar) -> c_int;
    pub fn git_repository_get_namespace(repo: *mut git_repository) ->
     *c_schar;
    pub fn git_repository_is_shallow(repo: *mut git_repository) -> c_int;
    pub fn git_revwalk_new(out: *mut *mut git_revwalk,
                           repo: *mut git_repository) -> c_int;
    pub fn git_revwalk_reset(walker: *mut git_revwalk);
    pub fn git_revwalk_push(walk: *mut git_revwalk, id: *git_oid) -> c_int;
    pub fn git_revwalk_push_glob(walk: *mut git_revwalk, glob: *c_schar) ->
     c_int;
    pub fn git_revwalk_push_head(walk: *mut git_revwalk) -> c_int;
    pub fn git_revwalk_hide(walk: *mut git_revwalk, commit_id: *git_oid) ->
     c_int;
    pub fn git_revwalk_hide_glob(walk: *mut git_revwalk, glob: *c_schar) ->
     c_int;
    pub fn git_revwalk_hide_head(walk: *mut git_revwalk) -> c_int;
    pub fn git_revwalk_push_ref(walk: *mut git_revwalk, refname: *c_schar) ->
     c_int;
    pub fn git_revwalk_hide_ref(walk: *mut git_revwalk, refname: *c_schar) ->
     c_int;
    pub fn git_revwalk_next(out: *mut git_oid, walk: *mut git_revwalk) ->
     c_int;
    pub fn git_revwalk_sorting(walk: *mut git_revwalk, sort_mode: c_uint);
    pub fn git_revwalk_push_range(walk: *mut git_revwalk, range: *c_schar) ->
     c_int;
    pub fn git_revwalk_free(walk: *mut git_revwalk);
    pub fn git_revwalk_repository(walk: *mut git_revwalk) ->
     *mut git_repository;
    pub fn git_object_lookup(object: *mut *mut git_object,
                             repo: *mut git_repository, id: *git_oid,
                             _type: git_otype) -> c_int;
    pub fn git_object_lookup_prefix(object_out: *mut *mut git_object,
                                    repo: *mut git_repository, id: *git_oid,
                                    len: size_t, _type: git_otype) -> c_int;
    pub fn git_object_id(obj: *git_object) -> *git_oid;
    pub fn git_object_type(obj: *git_object) -> git_otype;
    pub fn git_object_owner(obj: *git_object) -> *mut git_repository;
    pub fn git_object_free(object: *mut git_object);
    pub fn git_object_type2string(_type: git_otype) -> *c_schar;
    pub fn git_object_string2type(str: *c_schar) -> git_otype;
    pub fn git_object_typeisloose(_type: git_otype) -> c_int;
    pub fn git_object__size(_type: git_otype) -> size_t;
    pub fn git_object_peel(peeled: *mut *mut git_object, object: *git_object,
                           target_type: git_otype) -> c_int;
    pub fn git_object_dup(dest: *mut *mut git_object, source: *mut git_object)
     -> c_int;
    pub fn git_tree_lookup(out: *mut *mut git_tree, repo: *mut git_repository,
                           id: *git_oid) -> c_int;
    pub fn git_tree_lookup_prefix(out: *mut *mut git_tree,
                                  repo: *mut git_repository, id: *git_oid,
                                  len: size_t) -> c_int;
    pub fn git_tree_free(tree: *mut git_tree);
    pub fn git_tree_id(tree: *git_tree) -> *git_oid;
    pub fn git_tree_owner(tree: *git_tree) -> *mut git_repository;
    pub fn git_tree_entrycount(tree: *git_tree) -> size_t;
    pub fn git_tree_entry_byname(tree: *git_tree, filename: *c_schar) ->
     *git_tree_entry;
    pub fn git_tree_entry_byindex(tree: *git_tree, idx: size_t) ->
     *git_tree_entry;
    pub fn git_tree_entry_byoid(tree: *git_tree, oid: *git_oid) ->
     *git_tree_entry;
    pub fn git_tree_entry_bypath(out: *mut *mut git_tree_entry,
                                 root: *git_tree, path: *c_schar) -> c_int;
    pub fn git_tree_entry_dup(entry: *git_tree_entry) -> *mut git_tree_entry;
    pub fn git_tree_entry_free(entry: *mut git_tree_entry);
    pub fn git_tree_entry_name(entry: *git_tree_entry) -> *c_schar;
    pub fn git_tree_entry_id(entry: *git_tree_entry) -> *git_oid;
    pub fn git_tree_entry_type(entry: *git_tree_entry) -> git_otype;
    pub fn git_tree_entry_filemode(entry: *git_tree_entry) -> git_filemode_t;
    pub fn git_tree_entry_cmp(e1: *git_tree_entry, e2: *git_tree_entry) ->
     c_int;
    pub fn git_tree_entry_to_object(object_out: *mut *mut git_object,
                                    repo: *mut git_repository,
                                    entry: *git_tree_entry) -> c_int;
    pub fn git_treebuilder_create(out: *mut *mut git_treebuilder,
                                  source: *git_tree) -> c_int;
    pub fn git_treebuilder_clear(bld: *mut git_treebuilder);
    pub fn git_treebuilder_entrycount(bld: *mut git_treebuilder) -> c_uint;
    pub fn git_treebuilder_free(bld: *mut git_treebuilder);
    pub fn git_treebuilder_get(bld: *mut git_treebuilder, filename: *c_schar)
     -> *git_tree_entry;
    pub fn git_treebuilder_insert(out: *mut *git_tree_entry,
                                  bld: *mut git_treebuilder,
                                  filename: *c_schar, id: *git_oid,
                                  filemode: git_filemode_t) -> c_int;
    pub fn git_treebuilder_remove(bld: *mut git_treebuilder,
                                  filename: *c_schar) -> c_int;
    pub fn git_treebuilder_filter(bld: *mut git_treebuilder,
                                  filter: git_treebuilder_filter_cb,
                                  payload: *mut c_void);
    pub fn git_treebuilder_write(id: *mut git_oid, repo: *mut git_repository,
                                 bld: *mut git_treebuilder) -> c_int;
    pub fn git_tree_walk(tree: *git_tree, mode: git_treewalk_mode,
                         callback: git_treewalk_cb, payload: *mut c_void) ->
     c_int;
    pub fn git_strarray_free(array: *mut git_strarray);
    pub fn git_strarray_copy(tgt: *mut git_strarray, src: *git_strarray) ->
     c_int;
    pub fn git_reference_lookup(out: *mut *mut git_reference,
                                repo: *mut git_repository, name: *c_schar) ->
     c_int;
    pub fn git_reference_name_to_id(out: *mut git_oid,
                                    repo: *mut git_repository, name: *c_schar)
     -> c_int;
    pub fn git_reference_dwim(out: *mut *mut git_reference,
                              repo: *mut git_repository, shorthand: *c_schar)
     -> c_int;
    pub fn git_reference_symbolic_create(out: *mut *mut git_reference,
                                         repo: *mut git_repository,
                                         name: *c_schar, target: *c_schar,
                                         force: c_int) -> c_int;
    pub fn git_reference_create(out: *mut *mut git_reference,
                                repo: *mut git_repository, name: *c_schar,
                                id: *git_oid, force: c_int) -> c_int;
    pub fn git_reference_target(_ref: *git_reference) -> *git_oid;
    pub fn git_reference_target_peel(_ref: *git_reference) -> *git_oid;
    pub fn git_reference_symbolic_target(_ref: *git_reference) -> *c_schar;
    pub fn git_reference_type(_ref: *git_reference) -> git_ref_t;
    pub fn git_reference_name(_ref: *git_reference) -> *c_schar;
    pub fn git_reference_resolve(out: *mut *mut git_reference,
                                 _ref: *git_reference) -> c_int;
    pub fn git_reference_owner(_ref: *git_reference) -> *mut git_repository;
    pub fn git_reference_symbolic_set_target(out: *mut *mut git_reference,
                                             _ref: *mut git_reference,
                                             target: *c_schar) -> c_int;
    pub fn git_reference_set_target(out: *mut *mut git_reference,
                                    _ref: *mut git_reference, id: *git_oid) ->
     c_int;
    pub fn git_reference_rename(new_ref: *mut *mut git_reference,
                                _ref: *mut git_reference, new_name: *c_schar,
                                force: c_int) -> c_int;
    pub fn git_reference_delete(_ref: *mut git_reference) -> c_int;
    pub fn git_reference_list(array: *mut git_strarray,
                              repo: *mut git_repository) -> c_int;
    pub fn git_reference_foreach(repo: *mut git_repository,
                                 callback: git_reference_foreach_cb,
                                 payload: *mut c_void) -> c_int;
    pub fn git_reference_foreach_name(repo: *mut git_repository,
                                      callback: git_reference_foreach_name_cb,
                                      payload: *mut c_void) -> c_int;
    pub fn git_reference_free(_ref: *mut git_reference);
    pub fn git_reference_cmp(ref1: *mut git_reference,
                             ref2: *mut git_reference) -> c_int;
    pub fn git_reference_iterator_new(out: *mut *mut git_reference_iterator,
                                      repo: *mut git_repository) -> c_int;
    pub fn git_reference_iterator_glob_new(out:
                                               *mut *mut git_reference_iterator,
                                           repo: *mut git_repository,
                                           glob: *c_schar) -> c_int;
    pub fn git_reference_next(out: *mut *mut git_reference,
                              iter: *mut git_reference_iterator) -> c_int;
    pub fn git_reference_next_name(out: *mut *c_schar,
                                   iter: *mut git_reference_iterator) ->
     c_int;
    pub fn git_reference_iterator_free(iter: *mut git_reference_iterator);
    pub fn git_reference_foreach_glob(repo: *mut git_repository,
                                      glob: *c_schar,
                                      callback: git_reference_foreach_name_cb,
                                      payload: *mut c_void) -> c_int;
    pub fn git_reference_has_log(_ref: *mut git_reference) -> c_int;
    pub fn git_reference_is_branch(_ref: *mut git_reference) -> c_int;
    pub fn git_reference_is_remote(_ref: *mut git_reference) -> c_int;
    pub fn git_reference_is_tag(_ref: *mut git_reference) -> c_int;
    pub fn git_reference_normalize_name(buffer_out: *mut c_schar,
                                        buffer_size: size_t, name: *c_schar,
                                        flags: c_uint) -> c_int;
    pub fn git_reference_peel(out: *mut *mut git_object,
                              _ref: *mut git_reference, _type: git_otype) ->
     c_int;
    pub fn git_reference_is_valid_name(refname: *c_schar) -> c_int;
    pub fn git_reference_shorthand(_ref: *mut git_reference) -> *c_schar;
    pub fn git_diff_list_free(diff: *mut git_diff_list);
    pub fn git_diff_tree_to_tree(diff: *mut *mut git_diff_list,
                                 repo: *mut git_repository,
                                 old_tree: *mut git_tree,
                                 new_tree: *mut git_tree,
                                 opts: *git_diff_options) -> c_int;
    pub fn git_diff_tree_to_index(diff: *mut *mut git_diff_list,
                                  repo: *mut git_repository,
                                  old_tree: *mut git_tree,
                                  index: *mut git_index,
                                  opts: *git_diff_options) -> c_int;
    pub fn git_diff_index_to_workdir(diff: *mut *mut git_diff_list,
                                     repo: *mut git_repository,
                                     index: *mut git_index,
                                     opts: *git_diff_options) -> c_int;
    pub fn git_diff_tree_to_workdir(diff: *mut *mut git_diff_list,
                                    repo: *mut git_repository,
                                    old_tree: *mut git_tree,
                                    opts: *git_diff_options) -> c_int;
    pub fn git_diff_merge(onto: *mut git_diff_list, from: *git_diff_list) ->
     c_int;
    pub fn git_diff_find_similar(diff: *mut git_diff_list,
                                 options: *mut git_diff_find_options) ->
     c_int;
    pub fn git_diff_foreach(diff: *mut git_diff_list,
                            file_cb: git_diff_file_cb,
                            hunk_cb: git_diff_hunk_cb,
                            line_cb: git_diff_data_cb, payload: *mut c_void)
     -> c_int;
    pub fn git_diff_print_compact(diff: *mut git_diff_list,
                                  print_cb: git_diff_data_cb,
                                  payload: *mut c_void) -> c_int;
    pub fn git_diff_print_raw(diff: *mut git_diff_list,
                              print_cb: git_diff_data_cb,
                              payload: *mut c_void) -> c_int;
    pub fn git_diff_status_char(status: git_delta_t) -> c_schar;
    pub fn git_diff_print_patch(diff: *mut git_diff_list,
                                print_cb: git_diff_data_cb,
                                payload: *mut c_void) -> c_int;
    pub fn git_diff_num_deltas(diff: *mut git_diff_list) -> size_t;
    pub fn git_diff_num_deltas_of_type(diff: *mut git_diff_list,
                                       _type: git_delta_t) -> size_t;
    pub fn git_diff_is_sorted_icase(diff: *git_diff_list) -> c_int;
    pub fn git_diff_get_patch(patch_out: *mut *mut git_diff_patch,
                              delta_out: *mut *git_diff_delta,
                              diff: *mut git_diff_list, idx: size_t) -> c_int;
    pub fn git_diff_patch_free(patch: *mut git_diff_patch);
    pub fn git_diff_patch_delta(patch: *mut git_diff_patch) ->
     *git_diff_delta;
    pub fn git_diff_patch_num_hunks(patch: *mut git_diff_patch) -> size_t;
    pub fn git_diff_patch_line_stats(total_context: *mut size_t,
                                     total_additions: *mut size_t,
                                     total_deletions: *mut size_t,
                                     patch: *git_diff_patch) -> c_int;
    pub fn git_diff_patch_get_hunk(range: *mut *git_diff_range,
                                   header: *mut *c_schar,
                                   header_len: *mut size_t,
                                   lines_in_hunk: *mut size_t,
                                   patch: *mut git_diff_patch,
                                   hunk_idx: size_t) -> c_int;
    pub fn git_diff_patch_num_lines_in_hunk(patch: *mut git_diff_patch,
                                            hunk_idx: size_t) -> c_int;
    pub fn git_diff_patch_get_line_in_hunk(line_origin: *mut c_schar,
                                           content: *mut *c_schar,
                                           content_len: *mut size_t,
                                           old_lineno: *mut c_int,
                                           new_lineno: *mut c_int,
                                           patch: *mut git_diff_patch,
                                           hunk_idx: size_t,
                                           line_of_hunk: size_t) -> c_int;
    pub fn git_diff_patch_size(patch: *mut git_diff_patch,
                               include_context: c_int,
                               include_hunk_headers: c_int,
                               include_file_headers: c_int) -> size_t;
    pub fn git_diff_patch_print(patch: *mut git_diff_patch,
                                print_cb: git_diff_data_cb,
                                payload: *mut c_void) -> c_int;
    pub fn git_diff_patch_to_str(string: *mut *mut c_schar,
                                 patch: *mut git_diff_patch) -> c_int;
    pub fn git_diff_blobs(old_blob: *git_blob, old_as_path: *c_schar,
                          new_blob: *git_blob, new_as_path: *c_schar,
                          options: *git_diff_options,
                          file_cb: git_diff_file_cb,
                          hunk_cb: git_diff_hunk_cb,
                          line_cb: git_diff_data_cb, payload: *mut c_void) ->
     c_int;
    pub fn git_diff_patch_from_blobs(out: *mut *mut git_diff_patch,
                                     old_blob: *git_blob,
                                     old_as_path: *c_schar,
                                     new_blob: *git_blob,
                                     new_as_path: *c_schar,
                                     opts: *git_diff_options) -> c_int;
    pub fn git_diff_blob_to_buffer(old_blob: *git_blob, old_as_path: *c_schar,
                                   buffer: *c_schar, buffer_len: size_t,
                                   buffer_as_path: *c_schar,
                                   options: *git_diff_options,
                                   file_cb: git_diff_file_cb,
                                   hunk_cb: git_diff_hunk_cb,
                                   data_cb: git_diff_data_cb,
                                   payload: *mut c_void) -> c_int;
    pub fn git_diff_patch_from_blob_and_buffer(out: *mut *mut git_diff_patch,
                                               old_blob: *git_blob,
                                               old_as_path: *c_schar,
                                               buffer: *c_schar,
                                               buffer_len: size_t,
                                               buffer_as_path: *c_schar,
                                               opts: *git_diff_options) ->
     c_int;
    pub fn git_checkout_head(repo: *mut git_repository,
                             opts: *mut git_checkout_opts) -> c_int;
    pub fn git_checkout_index(repo: *mut git_repository,
                              index: *mut git_index,
                              opts: *mut git_checkout_opts) -> c_int;
    pub fn git_checkout_tree(repo: *mut git_repository, treeish: *git_object,
                             opts: *mut git_checkout_opts) -> c_int;
    pub fn git_indexer_stream_new(out: *mut *mut git_indexer_stream,
                                  path: *c_schar,
                                  progress_cb: git_transfer_progress_callback,
                                  progress_cb_payload: *mut c_void) -> c_int;
    pub fn git_indexer_stream_add(idx: *mut git_indexer_stream, data: *c_void,
                                  size: size_t,
                                  stats: *mut git_transfer_progress) -> c_int;
    pub fn git_indexer_stream_finalize(idx: *mut git_indexer_stream,
                                       stats: *mut git_transfer_progress) ->
     c_int;
    pub fn git_indexer_stream_hash(idx: *git_indexer_stream) -> *git_oid;
    pub fn git_indexer_stream_free(idx: *mut git_indexer_stream);
    pub fn git_index_open(out: *mut *mut git_index, index_path: *c_schar) ->
     c_int;
    pub fn git_index_new(out: *mut *mut git_index) -> c_int;
    pub fn git_index_free(index: *mut git_index);
    pub fn git_index_owner(index: *git_index) -> *mut git_repository;
    pub fn git_index_caps(index: *git_index) -> c_uint;
    pub fn git_index_set_caps(index: *mut git_index, caps: c_uint) -> c_int;
    pub fn git_index_read(index: *mut git_index) -> c_int;
    pub fn git_index_write(index: *mut git_index) -> c_int;
    pub fn git_index_path(index: *mut git_index) -> *c_schar;
    pub fn git_index_read_tree(index: *mut git_index, tree: *git_tree) ->
     c_int;
    pub fn git_index_write_tree(out: *mut git_oid, index: *mut git_index) ->
     c_int;
    pub fn git_index_write_tree_to(out: *mut git_oid, index: *mut git_index,
                                   repo: *mut git_repository) -> c_int;
    pub fn git_index_entrycount(index: *git_index) -> size_t;
    pub fn git_index_clear(index: *mut git_index);
    pub fn git_index_get_byindex(index: *mut git_index, n: size_t) ->
     *git_index_entry;
    pub fn git_index_get_bypath(index: *mut git_index, path: *c_schar,
                                stage: c_int) -> *git_index_entry;
    pub fn git_index_remove(index: *mut git_index, path: *c_schar,
                            stage: c_int) -> c_int;
    pub fn git_index_remove_directory(index: *mut git_index, dir: *c_schar,
                                      stage: c_int) -> c_int;
    pub fn git_index_add(index: *mut git_index,
                         source_entry: *git_index_entry) -> c_int;
    pub fn git_index_entry_stage(entry: *git_index_entry) -> c_int;
    pub fn git_index_add_bypath(index: *mut git_index, path: *c_schar) ->
     c_int;
    pub fn git_index_remove_bypath(index: *mut git_index, path: *c_schar) ->
     c_int;
    pub fn git_index_add_all(index: *mut git_index, pathspec: *git_strarray,
                             flags: c_uint,
                             callback: git_index_matched_path_cb,
                             payload: *mut c_void) -> c_int;
    pub fn git_index_remove_all(index: *mut git_index,
                                pathspec: *git_strarray,
                                callback: git_index_matched_path_cb,
                                payload: *mut c_void) -> c_int;
    pub fn git_index_update_all(index: *mut git_index,
                                pathspec: *git_strarray,
                                callback: git_index_matched_path_cb,
                                payload: *mut c_void) -> c_int;
    pub fn git_index_find(at_pos: *mut size_t, index: *mut git_index,
                          path: *c_schar) -> c_int;
    pub fn git_index_conflict_add(index: *mut git_index,
                                  ancestor_entry: *git_index_entry,
                                  our_entry: *git_index_entry,
                                  their_entry: *git_index_entry) -> c_int;
    pub fn git_index_conflict_get(ancestor_out: *mut *git_index_entry,
                                  our_out: *mut *git_index_entry,
                                  their_out: *mut *git_index_entry,
                                  index: *mut git_index, path: *c_schar) ->
     c_int;
    pub fn git_index_conflict_remove(index: *mut git_index, path: *c_schar) ->
     c_int;
    pub fn git_index_conflict_cleanup(index: *mut git_index);
    pub fn git_index_has_conflicts(index: *git_index) -> c_int;
    pub fn git_index_conflict_iterator_new(iterator_out:
                                               *mut *mut git_index_conflict_iterator,
                                           index: *mut git_index) -> c_int;
    pub fn git_index_conflict_next(ancestor_out: *mut *git_index_entry,
                                   our_out: *mut *git_index_entry,
                                   their_out: *mut *git_index_entry,
                                   iterator: *mut git_index_conflict_iterator)
     -> c_int;
    pub fn git_index_conflict_iterator_free(iterator:
                                                *mut git_index_conflict_iterator);
    pub fn git_merge_base(out: *mut git_oid, repo: *mut git_repository,
                          one: *git_oid, two: *git_oid) -> c_int;
    pub fn git_merge_base_many(out: *mut git_oid, repo: *mut git_repository,
                               input_array: *git_oid, length: size_t) ->
     c_int;
    pub fn git_merge_head_from_ref(out: *mut *mut git_merge_head,
                                   repo: *mut git_repository,
                                   _ref: *mut git_reference) -> c_int;
    pub fn git_merge_head_from_fetchhead(out: *mut *mut git_merge_head,
                                         repo: *mut git_repository,
                                         branch_name: *c_schar,
                                         remote_url: *c_schar, oid: *git_oid)
     -> c_int;
    pub fn git_merge_head_from_oid(out: *mut *mut git_merge_head,
                                   repo: *mut git_repository, oid: *git_oid)
     -> c_int;
    pub fn git_merge_head_free(head: *mut git_merge_head);
    pub fn git_merge_trees(out: *mut *mut git_index,
                           repo: *mut git_repository,
                           ancestor_tree: *git_tree, our_tree: *git_tree,
                           their_tree: *git_tree, opts: *git_merge_tree_opts)
     -> c_int;
    pub fn git_graph_ahead_behind(ahead: *mut size_t, behind: *mut size_t,
                                  repo: *mut git_repository, local: *git_oid,
                                  upstream: *git_oid) -> c_int;
    pub fn git_reflog_read(out: *mut *mut git_reflog, _ref: *git_reference) ->
     c_int;
    pub fn git_reflog_write(reflog: *mut git_reflog) -> c_int;
    pub fn git_reflog_append(reflog: *mut git_reflog, id: *git_oid,
                             committer: *git_signature, msg: *c_schar) ->
     c_int;
    pub fn git_reflog_rename(_ref: *mut git_reference, name: *c_schar) ->
     c_int;
    pub fn git_reflog_delete(_ref: *mut git_reference) -> c_int;
    pub fn git_reflog_entrycount(reflog: *mut git_reflog) -> size_t;
    pub fn git_reflog_entry_byindex(reflog: *mut git_reflog, idx: size_t) ->
     *git_reflog_entry;
    pub fn git_reflog_drop(reflog: *mut git_reflog, idx: size_t,
                           rewrite_previous_entry: c_int) -> c_int;
    pub fn git_reflog_entry_id_old(entry: *git_reflog_entry) -> *git_oid;
    pub fn git_reflog_entry_id_new(entry: *git_reflog_entry) -> *git_oid;
    pub fn git_reflog_entry_committer(entry: *git_reflog_entry) ->
     *git_signature;
    pub fn git_reflog_entry_message(entry: *git_reflog_entry) -> *c_schar;
    pub fn git_reflog_free(reflog: *mut git_reflog);
    pub fn git_revparse_single(out: *mut *mut git_object,
                               repo: *mut git_repository, spec: *c_schar) ->
     c_int;
    pub fn git_revparse_ext(object_out: *mut *mut git_object,
                            reference_out: *mut *mut git_reference,
                            repo: *mut git_repository, spec: *c_schar) ->
     c_int;
    pub fn git_revparse(revspec: *mut git_revspec, repo: *mut git_repository,
                        spec: *c_schar) -> c_int;
    pub fn git_blob_lookup(blob: *mut *mut git_blob,
                           repo: *mut git_repository, id: *git_oid) -> c_int;
    pub fn git_blob_lookup_prefix(blob: *mut *mut git_blob,
                                  repo: *mut git_repository, id: *git_oid,
                                  len: size_t) -> c_int;
    pub fn git_blob_free(blob: *mut git_blob);
    pub fn git_blob_id(blob: *git_blob) -> *git_oid;
    pub fn git_blob_owner(blob: *git_blob) -> *mut git_repository;
    pub fn git_blob_rawcontent(blob: *git_blob) -> *c_void;
    pub fn git_blob_rawsize(blob: *git_blob) -> git_off_t;
    pub fn git_blob_create_fromworkdir(id: *mut git_oid,
                                       repo: *mut git_repository,
                                       relative_path: *c_schar) -> c_int;
    pub fn git_blob_create_fromdisk(id: *mut git_oid,
                                    repo: *mut git_repository, path: *c_schar)
     -> c_int;
    pub fn git_blob_create_fromchunks(id: *mut git_oid,
                                      repo: *mut git_repository,
                                      hintpath: *c_schar,
                                      callback: git_blob_chunk_cb,
                                      payload: *mut c_void) -> c_int;
    pub fn git_blob_create_frombuffer(oid: *mut git_oid,
                                      repo: *mut git_repository,
                                      buffer: *c_void, len: size_t) -> c_int;
    pub fn git_blob_is_binary(blob: *mut git_blob) -> c_int;
    pub fn git_commit_lookup(commit: *mut *mut git_commit,
                             repo: *mut git_repository, id: *git_oid) ->
     c_int;
    pub fn git_commit_lookup_prefix(commit: *mut *mut git_commit,
                                    repo: *mut git_repository, id: *git_oid,
                                    len: size_t) -> c_int;
    pub fn git_commit_free(commit: *mut git_commit);
    pub fn git_commit_id(commit: *git_commit) -> *git_oid;
    pub fn git_commit_owner(commit: *git_commit) -> *mut git_repository;
    pub fn git_commit_message_encoding(commit: *git_commit) -> *c_schar;
    pub fn git_commit_message(commit: *git_commit) -> *c_schar;
    pub fn git_commit_time(commit: *git_commit) -> git_time_t;
    pub fn git_commit_time_offset(commit: *git_commit) -> c_int;
    pub fn git_commit_committer(commit: *git_commit) -> *git_signature;
    pub fn git_commit_author(commit: *git_commit) -> *git_signature;
    pub fn git_commit_raw_header(commit: *git_commit) -> *c_schar;
    pub fn git_commit_tree(tree_out: *mut *mut git_tree, commit: *git_commit)
     -> c_int;
    pub fn git_commit_tree_id(commit: *git_commit) -> *git_oid;
    pub fn git_commit_parentcount(commit: *git_commit) -> c_uint;
    pub fn git_commit_parent(out: *mut *mut git_commit, commit: *git_commit,
                             n: c_uint) -> c_int;
    pub fn git_commit_parent_id(commit: *git_commit, n: c_uint) -> *git_oid;
    pub fn git_commit_nth_gen_ancestor(ancestor: *mut *mut git_commit,
                                       commit: *git_commit, n: c_uint) ->
     c_int;
    pub fn git_commit_create(id: *mut git_oid, repo: *mut git_repository,
                             update_ref: *c_schar, author: *git_signature,
                             committer: *git_signature,
                             message_encoding: *c_schar, message: *c_schar,
                             tree: *git_tree, parent_count: c_int,
                             parents: *mut *git_commit) -> c_int;
    pub fn git_commit_create_v(id: *mut git_oid, repo: *mut git_repository,
                               update_ref: *c_schar, author: *git_signature,
                               committer: *git_signature,
                               message_encoding: *c_schar, message: *c_schar,
                               tree: *git_tree, parent_count: c_int) -> c_int;
    pub fn git_tag_lookup(out: *mut *mut git_tag, repo: *mut git_repository,
                          id: *git_oid) -> c_int;
    pub fn git_tag_lookup_prefix(out: *mut *mut git_tag,
                                 repo: *mut git_repository, id: *git_oid,
                                 len: size_t) -> c_int;
    pub fn git_tag_free(tag: *mut git_tag);
    pub fn git_tag_id(tag: *git_tag) -> *git_oid;
    pub fn git_tag_owner(tag: *git_tag) -> *mut git_repository;
    pub fn git_tag_target(target_out: *mut *mut git_object, tag: *git_tag) ->
     c_int;
    pub fn git_tag_target_id(tag: *git_tag) -> *git_oid;
    pub fn git_tag_target_type(tag: *git_tag) -> git_otype;
    pub fn git_tag_name(tag: *git_tag) -> *c_schar;
    pub fn git_tag_tagger(tag: *git_tag) -> *git_signature;
    pub fn git_tag_message(tag: *git_tag) -> *c_schar;
    pub fn git_tag_create(oid: *mut git_oid, repo: *mut git_repository,
                          tag_name: *c_schar, target: *git_object,
                          tagger: *git_signature, message: *c_schar,
                          force: c_int) -> c_int;
    pub fn git_tag_annotation_create(oid: *mut git_oid,
                                     repo: *mut git_repository,
                                     tag_name: *c_schar, target: *git_object,
                                     tagger: *git_signature,
                                     message: *c_schar) -> c_int;
    pub fn git_tag_create_frombuffer(oid: *mut git_oid,
                                     repo: *mut git_repository,
                                     buffer: *c_schar, force: c_int) -> c_int;
    pub fn git_tag_create_lightweight(oid: *mut git_oid,
                                      repo: *mut git_repository,
                                      tag_name: *c_schar, target: *git_object,
                                      force: c_int) -> c_int;
    pub fn git_tag_delete(repo: *mut git_repository, tag_name: *c_schar) ->
     c_int;
    pub fn git_tag_list(tag_names: *mut git_strarray,
                        repo: *mut git_repository) -> c_int;
    pub fn git_tag_list_match(tag_names: *mut git_strarray, pattern: *c_schar,
                              repo: *mut git_repository) -> c_int;
    pub fn git_tag_foreach(repo: *mut git_repository,
                           callback: git_tag_foreach_cb, payload: *mut c_void)
     -> c_int;
    pub fn git_tag_peel(tag_target_out: *mut *mut git_object, tag: *git_tag)
     -> c_int;
    pub fn git_config_find_global(out: *mut c_schar, length: size_t) -> c_int;
    pub fn git_config_find_xdg(out: *mut c_schar, length: size_t) -> c_int;
    pub fn git_config_find_system(out: *mut c_schar, length: size_t) -> c_int;
    pub fn git_config_open_default(out: *mut *mut git_config) -> c_int;
    pub fn git_config_new(out: *mut *mut git_config) -> c_int;
    pub fn git_config_add_file_ondisk(cfg: *mut git_config, path: *c_schar,
                                      level: git_config_level_t, force: c_int)
     -> c_int;
    pub fn git_config_open_ondisk(out: *mut *mut git_config, path: *c_schar)
     -> c_int;
    pub fn git_config_open_level(out: *mut *mut git_config,
                                 parent: *git_config,
                                 level: git_config_level_t) -> c_int;
    pub fn git_config_open_global(out: *mut *mut git_config,
                                  config: *mut git_config) -> c_int;
    pub fn git_config_refresh(cfg: *mut git_config) -> c_int;
    pub fn git_config_free(cfg: *mut git_config);
    pub fn git_config_get_entry(out: *mut *git_config_entry, cfg: *git_config,
                                name: *c_schar) -> c_int;
    pub fn git_config_get_int32(out: *mut int32_t, cfg: *git_config,
                                name: *c_schar) -> c_int;
    pub fn git_config_get_int64(out: *mut int64_t, cfg: *git_config,
                                name: *c_schar) -> c_int;
    pub fn git_config_get_bool(out: *mut c_int, cfg: *git_config,
                               name: *c_schar) -> c_int;
    pub fn git_config_get_string(out: *mut *c_schar, cfg: *git_config,
                                 name: *c_schar) -> c_int;
    pub fn git_config_get_multivar_foreach(cfg: *git_config, name: *c_schar,
                                           regexp: *c_schar,
                                           callback: git_config_foreach_cb,
                                           payload: *mut c_void) -> c_int;
    pub fn git_config_multivar_iterator_new(out:
                                                *mut *mut git_config_iterator,
                                            cfg: *git_config, name: *c_schar,
                                            regexp: *c_schar) -> c_int;
    pub fn git_config_next(entry: *mut *mut git_config_entry,
                           iter: *mut git_config_iterator) -> c_int;
    pub fn git_config_iterator_free(iter: *mut git_config_iterator);
    pub fn git_config_set_int32(cfg: *mut git_config, name: *c_schar,
                                value: int32_t) -> c_int;
    pub fn git_config_set_int64(cfg: *mut git_config, name: *c_schar,
                                value: int64_t) -> c_int;
    pub fn git_config_set_bool(cfg: *mut git_config, name: *c_schar,
                               value: c_int) -> c_int;
    pub fn git_config_set_string(cfg: *mut git_config, name: *c_schar,
                                 value: *c_schar) -> c_int;
    pub fn git_config_set_multivar(cfg: *mut git_config, name: *c_schar,
                                   regexp: *c_schar, value: *c_schar) ->
     c_int;
    pub fn git_config_delete_entry(cfg: *mut git_config, name: *c_schar) ->
     c_int;
    pub fn git_config_foreach(cfg: *git_config,
                              callback: git_config_foreach_cb,
                              payload: *mut c_void) -> c_int;
    pub fn git_config_iterator_new(out: *mut *mut git_config_iterator,
                                   cfg: *git_config) -> c_int;
    pub fn git_config_iterator_glob_new(out: *mut *mut git_config_iterator,
                                        cfg: *git_config, regexp: *c_schar) ->
     c_int;
    pub fn git_config_foreach_match(cfg: *git_config, regexp: *c_schar,
                                    callback: git_config_foreach_cb,
                                    payload: *mut c_void) -> c_int;
    pub fn git_config_get_mapped(out: *mut c_int, cfg: *git_config,
                                 name: *c_schar, maps: *git_cvar_map,
                                 map_n: size_t) -> c_int;
    pub fn git_config_lookup_map_value(out: *mut c_int, maps: *git_cvar_map,
                                       map_n: size_t, value: *c_schar) ->
     c_int;
    pub fn git_config_parse_bool(out: *mut c_int, value: *c_schar) -> c_int;
    pub fn git_config_parse_int32(out: *mut int32_t, value: *c_schar) ->
     c_int;
    pub fn git_config_parse_int64(out: *mut int64_t, value: *c_schar) ->
     c_int;
    pub fn git_config_backend_foreach_match(backend: *mut git_config_backend,
                                            regexp: *c_schar,
                                            _fn:
                                                extern "C" fn
                                                    (arg1: *git_config_entry,
                                                     arg2: *mut c_void)
                                                    -> c_int,
                                            data: *mut c_void) -> c_int;
    pub fn git_cred_has_username(cred: *mut git_cred) -> c_int;
    pub fn git_cred_userpass_plaintext_new(out: *mut *mut git_cred,
                                           username: *c_schar,
                                           password: *c_schar) -> c_int;
    pub fn git_cred_ssh_keyfile_passphrase_new(out: *mut *mut git_cred,
                                               username: *c_schar,
                                               publickey: *c_schar,
                                               privatekey: *c_schar,
                                               passphrase: *c_schar) -> c_int;
    pub fn git_cred_ssh_publickey_new(out: *mut *mut git_cred,
                                      username: *c_schar, publickey: *c_schar,
                                      publickey_len: size_t,
                                      sign_fn: git_cred_sign_callback,
                                      sign_data: *mut c_void) -> c_int;
    pub fn git_transport_new(out: *mut *mut git_transport,
                             owner: *mut git_remote, url: *c_schar) -> c_int;
    pub fn git_transport_dummy(out: *mut *mut git_transport,
                               owner: *mut git_remote, payload: *mut c_void)
     -> c_int;
    pub fn git_transport_local(out: *mut *mut git_transport,
                               owner: *mut git_remote, payload: *mut c_void)
     -> c_int;
    pub fn git_transport_smart(out: *mut *mut git_transport,
                               owner: *mut git_remote, payload: *mut c_void)
     -> c_int;
    pub fn git_smart_subtransport_http(out: *mut *mut git_smart_subtransport,
                                       owner: *mut git_transport) -> c_int;
    pub fn git_smart_subtransport_git(out: *mut *mut git_smart_subtransport,
                                      owner: *mut git_transport) -> c_int;
    pub fn git_smart_subtransport_ssh(out: *mut *mut git_smart_subtransport,
                                      owner: *mut git_transport) -> c_int;
    pub fn git_refspec_src(refspec: *git_refspec) -> *c_schar;
    pub fn git_refspec_dst(refspec: *git_refspec) -> *c_schar;
    pub fn git_refspec_string(refspec: *git_refspec) -> *c_schar;
    pub fn git_refspec_force(refspec: *git_refspec) -> c_int;
    pub fn git_refspec_direction(spec: *git_refspec) -> git_direction;
    pub fn git_refspec_src_matches(refspec: *git_refspec, refname: *c_schar)
     -> c_int;
    pub fn git_refspec_dst_matches(refspec: *git_refspec, refname: *c_schar)
     -> c_int;
    pub fn git_refspec_transform(out: *mut c_schar, outlen: size_t,
                                 spec: *git_refspec, name: *c_schar) -> c_int;
    pub fn git_refspec_rtransform(out: *mut c_schar, outlen: size_t,
                                  spec: *git_refspec, name: *c_schar) ->
     c_int;
    pub fn git_remote_create(out: *mut *mut git_remote,
                             repo: *mut git_repository, name: *c_schar,
                             url: *c_schar) -> c_int;
    pub fn git_remote_create_inmemory(out: *mut *mut git_remote,
                                      repo: *mut git_repository,
                                      fetch: *c_schar, url: *c_schar) ->
     c_int;
    pub fn git_remote_load(out: *mut *mut git_remote,
                           repo: *mut git_repository, name: *c_schar) ->
     c_int;
    pub fn git_remote_save(remote: *git_remote) -> c_int;
    pub fn git_remote_owner(remote: *git_remote) -> *mut git_repository;
    pub fn git_remote_name(remote: *git_remote) -> *c_schar;
    pub fn git_remote_url(remote: *git_remote) -> *c_schar;
    pub fn git_remote_pushurl(remote: *git_remote) -> *c_schar;
    pub fn git_remote_set_url(remote: *mut git_remote, url: *c_schar) ->
     c_int;
    pub fn git_remote_set_pushurl(remote: *mut git_remote, url: *c_schar) ->
     c_int;
    pub fn git_remote_add_fetch(remote: *mut git_remote, refspec: *c_schar) ->
     c_int;
    pub fn git_remote_get_fetch_refspecs(array: *mut git_strarray,
                                         remote: *mut git_remote) -> c_int;
    pub fn git_remote_add_push(remote: *mut git_remote, refspec: *c_schar) ->
     c_int;
    pub fn git_remote_get_push_refspecs(array: *mut git_strarray,
                                        remote: *mut git_remote) -> c_int;
    pub fn git_remote_clear_refspecs(remote: *mut git_remote);
    pub fn git_remote_refspec_count(remote: *mut git_remote) -> size_t;
    pub fn git_remote_get_refspec(remote: *mut git_remote, n: size_t) ->
     *git_refspec;
    pub fn git_remote_remove_refspec(remote: *mut git_remote, n: size_t) ->
     c_int;
    pub fn git_remote_connect(remote: *mut git_remote,
                              direction: git_direction) -> c_int;
    pub fn git_remote_ls(remote: *mut git_remote, list_cb: git_headlist_cb,
                         payload: *mut c_void) -> c_int;
    pub fn git_remote_download(remote: *mut git_remote,
                               progress_cb: git_transfer_progress_callback,
                               payload: *mut c_void) -> c_int;
    pub fn git_remote_connected(remote: *mut git_remote) -> c_int;
    pub fn git_remote_stop(remote: *mut git_remote);
    pub fn git_remote_disconnect(remote: *mut git_remote);
    pub fn git_remote_free(remote: *mut git_remote);
    pub fn git_remote_update_tips(remote: *mut git_remote) -> c_int;
    pub fn git_remote_valid_url(url: *c_schar) -> c_int;
    pub fn git_remote_supported_url(url: *c_schar) -> c_int;
    pub fn git_remote_list(out: *mut git_strarray, repo: *mut git_repository)
     -> c_int;
    pub fn git_remote_check_cert(remote: *mut git_remote, check: c_int);
    pub fn git_remote_set_cred_acquire_cb(remote: *mut git_remote,
                                          cred_acquire_cb:
                                              git_cred_acquire_cb,
                                          payload: *mut c_void);
    pub fn git_remote_set_transport(remote: *mut git_remote,
                                    transport: *mut git_transport) -> c_int;
    pub fn git_remote_set_callbacks(remote: *mut git_remote,
                                    callbacks: *mut git_remote_callbacks) ->
     c_int;
    pub fn git_remote_stats(remote: *mut git_remote) ->
     *git_transfer_progress;
    pub fn git_remote_autotag(remote: *mut git_remote) ->
     git_remote_autotag_option_t;
    pub fn git_remote_set_autotag(remote: *mut git_remote,
                                  value: git_remote_autotag_option_t);
    pub fn git_remote_rename(remote: *mut git_remote, new_name: *c_schar,
                             callback: git_remote_rename_problem_cb,
                             payload: *mut c_void) -> c_int;
    pub fn git_remote_update_fetchhead(remote: *mut git_remote) -> c_int;
    pub fn git_remote_set_update_fetchhead(remote: *mut git_remote,
                                           value: c_int);
    pub fn git_remote_is_valid_name(remote_name: *c_schar) -> c_int;
    pub fn git_clone(out: *mut *mut git_repository, url: *c_schar,
                     local_path: *c_schar, options: *git_clone_options) ->
     c_int;
    pub fn git_push_new(out: *mut *mut git_push, remote: *mut git_remote) ->
     c_int;
    pub fn git_push_set_options(push: *mut git_push, opts: *git_push_options)
     -> c_int;
    pub fn git_push_add_refspec(push: *mut git_push, refspec: *c_schar) ->
     c_int;
    pub fn git_push_update_tips(push: *mut git_push) -> c_int;
    pub fn git_push_finish(push: *mut git_push) -> c_int;
    pub fn git_push_unpack_ok(push: *mut git_push) -> c_int;
    pub fn git_push_status_foreach(push: *mut git_push,
                                   cb:
                                       extern "C" fn
                                           (arg1: *c_schar, arg2: *c_schar,
                                            arg3: *mut c_void) -> c_int,
                                   data: *mut c_void) -> c_int;
    pub fn git_push_free(push: *mut git_push);
    pub fn git_attr_value(attr: *c_schar) -> git_attr_t;
    pub fn git_attr_get(value_out: *mut *c_schar, repo: *mut git_repository,
                        flags: uint32_t, path: *c_schar, name: *c_schar) ->
     c_int;
    pub fn git_attr_get_many(values_out: *mut *c_schar,
                             repo: *mut git_repository, flags: uint32_t,
                             path: *c_schar, num_attr: size_t,
                             names: *mut *c_schar) -> c_int;
    pub fn git_attr_foreach(repo: *mut git_repository, flags: uint32_t,
                            path: *c_schar, callback: git_attr_foreach_cb,
                            payload: *mut c_void) -> c_int;
    pub fn git_attr_cache_flush(repo: *mut git_repository);
    pub fn git_attr_add_macro(repo: *mut git_repository, name: *c_schar,
                              values: *c_schar) -> c_int;
    pub fn git_ignore_add_rule(repo: *mut git_repository, rules: *c_schar) ->
     c_int;
    pub fn git_ignore_clear_internal_rules(repo: *mut git_repository) ->
     c_int;
    pub fn git_ignore_path_is_ignored(ignored: *mut c_int,
                                      repo: *mut git_repository,
                                      path: *c_schar) -> c_int;
    pub fn git_branch_create(out: *mut *mut git_reference,
                             repo: *mut git_repository, branch_name: *c_schar,
                             target: *git_commit, force: c_int) -> c_int;
    pub fn git_branch_delete(branch: *mut git_reference) -> c_int;
    pub fn git_branch_foreach(repo: *mut git_repository, list_flags: c_uint,
                              branch_cb: git_branch_foreach_cb,
                              payload: *mut c_void) -> c_int;
    pub fn git_branch_move(out: *mut *mut git_reference,
                           branch: *mut git_reference,
                           new_branch_name: *c_schar, force: c_int) -> c_int;
    pub fn git_branch_lookup(out: *mut *mut git_reference,
                             repo: *mut git_repository, branch_name: *c_schar,
                             branch_type: git_branch_t) -> c_int;
    pub fn git_branch_name(out: *mut *c_schar, _ref: *mut git_reference) ->
     c_int;
    pub fn git_branch_upstream(out: *mut *mut git_reference,
                               branch: *mut git_reference) -> c_int;
    pub fn git_branch_set_upstream(branch: *mut git_reference,
                                   upstream_name: *c_schar) -> c_int;
    pub fn git_branch_upstream_name(tracking_branch_name_out: *mut c_schar,
                                    buffer_size: size_t,
                                    repo: *mut git_repository,
                                    canonical_branch_name: *c_schar) -> c_int;
    pub fn git_branch_is_head(branch: *mut git_reference) -> c_int;
    pub fn git_branch_remote_name(remote_name_out: *mut c_schar,
                                  buffer_size: size_t,
                                  repo: *mut git_repository,
                                  canonical_branch_name: *c_schar) -> c_int;
    pub fn git_status_foreach(repo: *mut git_repository,
                              callback: git_status_cb, payload: *mut c_void)
     -> c_int;
    pub fn git_status_foreach_ext(repo: *mut git_repository,
                                  opts: *git_status_options,
                                  callback: git_status_cb,
                                  payload: *mut c_void) -> c_int;
    pub fn git_status_file(status_flags: *mut c_uint,
                           repo: *mut git_repository, path: *c_schar) ->
     c_int;
    pub fn git_status_list_new(out: *mut *mut git_status_list,
                               repo: *mut git_repository,
                               opts: *git_status_options) -> c_int;
    pub fn git_status_list_entrycount(statuslist: *mut git_status_list) ->
     size_t;
    pub fn git_status_byindex(statuslist: *mut git_status_list, idx: size_t)
     -> *git_status_entry;
    pub fn git_status_list_free(statuslist: *mut git_status_list);
    pub fn git_status_should_ignore(ignored: *mut c_int,
                                    repo: *mut git_repository, path: *c_schar)
     -> c_int;
    pub fn git_submodule_lookup(submodule: *mut *mut git_submodule,
                                repo: *mut git_repository, name: *c_schar) ->
     c_int;
    pub fn git_submodule_foreach(repo: *mut git_repository,
                                 callback:
                                     extern "C" fn
                                         (arg1: *mut git_submodule,
                                          arg2: *c_schar, arg3: *mut c_void)
                                         -> c_int, payload: *mut c_void) ->
     c_int;
    pub fn git_submodule_add_setup(submodule: *mut *mut git_submodule,
                                   repo: *mut git_repository, url: *c_schar,
                                   path: *c_schar, use_gitlink: c_int) ->
     c_int;
    pub fn git_submodule_add_finalize(submodule: *mut git_submodule) -> c_int;
    pub fn git_submodule_add_to_index(submodule: *mut git_submodule,
                                      write_index: c_int) -> c_int;
    pub fn git_submodule_save(submodule: *mut git_submodule) -> c_int;
    pub fn git_submodule_owner(submodule: *mut git_submodule) ->
     *mut git_repository;
    pub fn git_submodule_name(submodule: *mut git_submodule) -> *c_schar;
    pub fn git_submodule_path(submodule: *mut git_submodule) -> *c_schar;
    pub fn git_submodule_url(submodule: *mut git_submodule) -> *c_schar;
    pub fn git_submodule_set_url(submodule: *mut git_submodule, url: *c_schar)
     -> c_int;
    pub fn git_submodule_index_id(submodule: *mut git_submodule) -> *git_oid;
    pub fn git_submodule_head_id(submodule: *mut git_submodule) -> *git_oid;
    pub fn git_submodule_wd_id(submodule: *mut git_submodule) -> *git_oid;
    pub fn git_submodule_ignore(submodule: *mut git_submodule) ->
     git_submodule_ignore_t;
    pub fn git_submodule_set_ignore(submodule: *mut git_submodule,
                                    ignore: git_submodule_ignore_t) ->
     git_submodule_ignore_t;
    pub fn git_submodule_update(submodule: *mut git_submodule) ->
     git_submodule_update_t;
    pub fn git_submodule_set_update(submodule: *mut git_submodule,
                                    update: git_submodule_update_t) ->
     git_submodule_update_t;
    pub fn git_submodule_fetch_recurse_submodules(submodule:
                                                      *mut git_submodule) ->
     c_int;
    pub fn git_submodule_set_fetch_recurse_submodules(submodule:
                                                          *mut git_submodule,
                                                      fetch_recurse_submodules:
                                                          c_int) -> c_int;
    pub fn git_submodule_init(submodule: *mut git_submodule, overwrite: c_int)
     -> c_int;
    pub fn git_submodule_sync(submodule: *mut git_submodule) -> c_int;
    pub fn git_submodule_open(repo: *mut *mut git_repository,
                              submodule: *mut git_submodule) -> c_int;
    pub fn git_submodule_reload(submodule: *mut git_submodule) -> c_int;
    pub fn git_submodule_reload_all(repo: *mut git_repository) -> c_int;
    pub fn git_submodule_status(status: *mut c_uint,
                                submodule: *mut git_submodule) -> c_int;
    pub fn git_submodule_location(location_status: *mut c_uint,
                                  submodule: *mut git_submodule) -> c_int;
    pub fn git_note_iterator_new(out: *mut *mut git_note_iterator,
                                 repo: *mut git_repository,
                                 notes_ref: *c_schar) -> c_int;
    pub fn git_note_iterator_free(it: *mut git_note_iterator);
    pub fn git_note_next(note_id: *mut git_oid, annotated_id: *mut git_oid,
                         it: *mut git_note_iterator) -> c_int;
    pub fn git_note_read(out: *mut *mut git_note, repo: *mut git_repository,
                         notes_ref: *c_schar, oid: *git_oid) -> c_int;
    pub fn git_note_message(note: *git_note) -> *c_schar;
    pub fn git_note_oid(note: *git_note) -> *git_oid;
    pub fn git_note_create(out: *mut git_oid, repo: *mut git_repository,
                           author: *git_signature, committer: *git_signature,
                           notes_ref: *c_schar, oid: *git_oid, note: *c_schar,
                           force: c_int) -> c_int;
    pub fn git_note_remove(repo: *mut git_repository, notes_ref: *c_schar,
                           author: *git_signature, committer: *git_signature,
                           oid: *git_oid) -> c_int;
    pub fn git_note_free(note: *mut git_note);
    pub fn git_note_default_ref(out: *mut *c_schar, repo: *mut git_repository)
     -> c_int;
    pub fn git_note_foreach(repo: *mut git_repository, notes_ref: *c_schar,
                            note_cb: git_note_foreach_cb,
                            payload: *mut c_void) -> c_int;
    pub fn git_reset(repo: *mut git_repository, target: *mut git_object,
                     reset_type: git_reset_t) -> c_int;
    pub fn git_reset_default(repo: *mut git_repository,
                             target: *mut git_object,
                             pathspecs: *mut git_strarray) -> c_int;
    pub fn git_message_prettify(out: *mut c_schar, out_size: size_t,
                                message: *c_schar, strip_comments: c_int) ->
     c_int;
    pub fn git_packbuilder_new(out: *mut *mut git_packbuilder,
                               repo: *mut git_repository) -> c_int;
    pub fn git_packbuilder_set_threads(pb: *mut git_packbuilder, n: c_uint) ->
     c_uint;
    pub fn git_packbuilder_insert(pb: *mut git_packbuilder, id: *git_oid,
                                  name: *c_schar) -> c_int;
    pub fn git_packbuilder_insert_tree(pb: *mut git_packbuilder, id: *git_oid)
     -> c_int;
    pub fn git_packbuilder_insert_commit(pb: *mut git_packbuilder,
                                         id: *git_oid) -> c_int;
    pub fn git_packbuilder_write(pb: *mut git_packbuilder, path: *c_schar,
                                 progress_cb: git_transfer_progress_callback,
                                 progress_cb_payload: *mut c_void) -> c_int;
    pub fn git_packbuilder_foreach(pb: *mut git_packbuilder,
                                   cb: git_packbuilder_foreach_cb,
                                   payload: *mut c_void) -> c_int;
    pub fn git_packbuilder_object_count(pb: *mut git_packbuilder) -> uint32_t;
    pub fn git_packbuilder_written(pb: *mut git_packbuilder) -> uint32_t;
    pub fn git_packbuilder_free(pb: *mut git_packbuilder);
    pub fn git_stash_save(out: *mut git_oid, repo: *mut git_repository,
                          stasher: *git_signature, message: *c_schar,
                          flags: c_uint) -> c_int;
    pub fn git_stash_foreach(repo: *mut git_repository,
                             callback: git_stash_cb, payload: *mut c_void) ->
     c_int;
    pub fn git_stash_drop(repo: *mut git_repository, index: size_t) -> c_int;
    pub fn git_pathspec_new(out: *mut *mut git_pathspec,
                            pathspec: *git_strarray) -> c_int;
    pub fn git_pathspec_free(ps: *mut git_pathspec);
    pub fn git_pathspec_matches_path(ps: *git_pathspec, flags: uint32_t,
                                     path: *c_schar) -> c_int;
    pub fn git_pathspec_match_workdir(out: *mut *mut git_pathspec_match_list,
                                      repo: *mut git_repository,
                                      flags: uint32_t, ps: *mut git_pathspec)
     -> c_int;
    pub fn git_pathspec_match_index(out: *mut *mut git_pathspec_match_list,
                                    index: *mut git_index, flags: uint32_t,
                                    ps: *mut git_pathspec) -> c_int;
    pub fn git_pathspec_match_tree(out: *mut *mut git_pathspec_match_list,
                                   tree: *mut git_tree, flags: uint32_t,
                                   ps: *mut git_pathspec) -> c_int;
    pub fn git_pathspec_match_diff(out: *mut *mut git_pathspec_match_list,
                                   diff: *mut git_diff_list, flags: uint32_t,
                                   ps: *mut git_pathspec) -> c_int;
    pub fn git_pathspec_match_list_free(m: *mut git_pathspec_match_list);
    pub fn git_pathspec_match_list_entrycount(m: *git_pathspec_match_list) ->
     size_t;
    pub fn git_pathspec_match_list_entry(m: *git_pathspec_match_list,
                                         pos: size_t) -> *c_schar;
    pub fn git_pathspec_match_list_diff_entry(m: *git_pathspec_match_list,
                                              pos: size_t) -> *git_diff_delta;
    pub fn git_pathspec_match_list_failed_entrycount(m:
                                                         *git_pathspec_match_list)
     -> size_t;
    pub fn git_pathspec_match_list_failed_entry(m: *git_pathspec_match_list,
                                                pos: size_t) -> *c_schar;
}
